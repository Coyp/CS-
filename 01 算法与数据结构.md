# 图
## 表示方法
### 邻接矩阵
```c
vector<vector<int>> grap;
```
### 邻接链表
```c
map<string, multiset<string>> grap;
map<string, list<string>> grap;
```
## 图算法
### DFS
1.非递归  
使用stack  
2.递归  
```c
void dfs(map<string, multiset<string>>& grap, string &currNode)
{
    while (!grap[currNode].empty())
    {
        string nextNode = *grap[currNode].begin();
        grap[currNode].earse(grap[currNode].begin());
        dfs(grap, nextNode);
    }
    
    res.push_back(currNode);
}

void dfs(vector<vector<int>>& grap, vector<vector<int>>& visted, int from)
{
    for (int i = from; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grap[i][j] && visted[i][j] == false)
            {
                visted[i][j] = true;
                dfs();
            }
        }
    }
}
```
### BFS
1.非递归  
使用队列  

### A*

### Dijkstra
使用最小堆  
