# 一、计算机基础  
## 信息存储与表示  
### 1.信息存储  
1）字节（byte）  
最小的可寻址的最小单位（8位的块）>> 1字节 = 8位  
每个字节都由一个唯一的数字来标识，也就是叫做地址
2）字  
整数和指针数据的标称大小，虚拟地址是通过一个字来编码，所以字决定了虚拟地址空间的最大大小
32位系统：2^32B(字节) = 4 * 2^20 KB = 4 * 2^10 MB = 4 GB
### 2.引用的存储
引用在编译器角度本质是常量的指针，实现和指针一样  
引用本身和指针所占大小相同，而sizeof(引用) = 引用绑定的对象的类型大小  

# 二、C++相关  
## STL
### 总结
vector —— 数组 （唯一有迭代器失效的，因为内存位置会变）   
list —— 双向链表  
dequeu —— 双端队列（数组+链表结合）   
map —— 红黑树  
set —— 红黑树  
unordered_map —— hash  
// 以下为STL的扩展  
stack —— list  
queue —— list  
priority_queue —— vector 
### 1.string  
#### 1.字符串转换问题  
字符串到数字 std::stoi()   
数字到字符串 std::to_string()  
#### 2.字符串流处理  
数据流读：istringstream >> ： 读时候以" "为分割符  
数据流写：ostringstream  <<   
```c
    string str="i an a boy";  
    istringstream is(str);  
    string s;  
    while(is>>s)  
    {  
        cout<<s<<endl;  
    }  
 ```
 #### 3.size()和length()的区别
 没有区别。。。
 
### 2.set

## 类概念相关  
### 1.空类的大小  
（sizeof） = 1，声明类型的实例时，必须在内存中占有一定的内存  
### 2.运算符重载  
1）参数个数  
当重载为类的成员函数时，函数的参数个数比原来参与运算的运算数少一个：重载一元运算符没有参数、重载二元运算符只有一个参数；比如，a + b 的参数为1个，a = b 的参数为1个  
当重载为类的友元函数时，参数个数与原运算数个数相同，因为没有this指针  
2）<<和>>只能用友元函数来重载  
为了保证使用cin或者cout  
### 3.写自己的string类  
```c
class MyString 
{
public:
	MyString(const char *str);
	MyString(const MyString &other);
	MyString &operator =(const MyString &other);
	~MyString();
private:
	char *data_;
};
 
MyString::MyString(const char *str) // str中已经包含了空的情况
{
	if (str == nullptr)
	{
		data_ = new char[1];
		data_[0] = '\0';
	}
	else
	{
		int length = strlen(str); // 到'\0'停止，因此要开length+1的长度
		data_ = new char[length + 1];
		strcpy(data_, str);
	}
}
 
// 拷贝构造函数啊，就是用来构造用的啊。因此不需要再初始化成员变量
// string a = b; 也是拷贝构造函数
MyString::MyString(const MyString &other) 
{
	int length = strlen(other.data_);
	this->data_ = new char[length + 1];
	strcpy(this->data_, other.data_);
}

//右值引用——移动构造函数
MyString::MyString(MyString &&other)
{
    this->data_ = other.data_;
    other.data_ = nullptr; // 右值必须被修改，否则会被释放
}

MyString& MyString::operator =(const MyString &other) // = 意味着之前已经有值了
{
	if (&other == this) return *this;
 
	// 
	delete[]this->data_;
 
	int length = strlen(other.data_);
	this->data_ = new char[length + 1];
	strcpy(this->data_, other.data_);
 
	return *this; // 这样返回可以做复合操作
}
 
MyString::~MyString()
{
	delete[] data_;
}
```

### 4.构造函数与析构函数  
1）  
构造函数是否能为虚函数：不能，构造函数的意义就是把这个类型给创建起来，地基都没有了谈什么  
析构函数是否能为虚函数：如果基类有派生类，则必须，否则会导致派生类的析构函数不能执行  
2）  
派生类构造函数调用重写函数：可以表现多态性 （说明构造函数执行前虚指针与虚表已经完成）  
派生类析构函数调用重写函数：可以表现多态性  
3）  
若构造函数与析构函数为私有函数  
构造函数和析构函数的调用是外部调用，因此设置为私有意味着不能完成实例化，但是可以通过static单例的方式创建在堆上  
### 5.类内成员变量初始化  
```c
class Test
{
public:
    Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。
    ~Test(){}
 
    int y;      //普通变量成员
    int &r;     //引用成员变量,C11之前必须通过参数初始化列表进行初始化
    const int d;    //常量成员变量，C11之前必须通过参数初始化列表进行初始化
    static int c;   //静态成员变量，不属于类的实例，必须在类外部定义实现
    static const int x = 2.1;   //静态常量整型成员变量
    static const int xx;        //静态常量整型成员变量声明
};
  
const int Test::xx = 4; //静态常量整型成员变量定义
int Test::c = 2;
```
### 6.类实例化的过程  
1）分配空间  
2）初始化  
https://blog.csdn.net/gukesdo/article/details/7514080  
### 7.虚函数与虚表  
1）同一个类产生的所有实例的虚指针都指向同一个虚表地址，因此虚表在全局变量区  
2）虚指针初始化与参数初始化一起执行，完成后再执行构造函数{ }里面的内容  

## 函数
### 1.std::sort() 排序方法
https://blog.csdn.net/ihadl/article/details/7400929  
1）仿函数 
```c
less<int>()  
```
2）自定义仿函数  
```c
struct cmp
{
    bool operator()(const Interval &a, const Interval &b) //重载了() 
    {
        return a.start < b.start; // 一定要用大于或者小于号
    }
};

```
3）全局函数 
```c
bool less_second(const myclass & m1, const myclass & m2) {
    return m1.second < m2.second; 
}
```
4）类内重载符号  
```c
class myclass {
	bool operator < (const myclass &m)const {
		return first < m.first;
	}
};
```
### 2.函数返回值
1）返回后构造出新的b来，a是被析构掉的
```c
string getString()
{
    string a = "123";
    return a;
}

string b = getString() // ok,b重新被构造，而a被析构

string &getString()
{
    string a = "123";
    return a;
}

string b = getString(); // 此时返回a的引用，但是a被析构，因此b会是空的
```


## 内存相关
### 1.malloc()  
1）内存是块状链表形式：头部包括自身指针、下一块指针、内存大小  
2）申请：从空闲的链表中拿到，若大小合适直接从空闲链表中取下；若大小太大，则根据申请大小修改内存头部一部分留在空闲链表，一部分拿下来  
3）释放：扫描空闲链表寻找合适的位置，若存在相邻的空闲块，则进行合并，减少碎片  
### 2.STL释放内存
1.含有reserve()/capacity()的容器才需要使用swap释放空间，仅有vector和string符合，其余无效  
2.

## 关键字  
### 1.sizeof() 
// 求类型大小的关键字，可以省略括号  
1）数组：int[10] a; -> sizeof(a) 10\*4 = 40  
2）其他为类型的字节大小 int \*a; -> sizeof(a)  4  
3）若数组作为函数的参数进行传参时，数组会自动退化为指针  
int GetSize(int data[]) { sizeof(data); } // 此时求的是指针的大小  
### 2.static
1) 用法  
a. C语言  
第一种：函数内修饰变量，生命周期长于该函数；  
第二种：文件级别（函数外），修饰变量或函数，表示只在本文件可见 —— 新标准中推荐使用匿名空间实现  
b. C++语言  
第三种：修饰class数据成员（静态成员），生命周期长于对象  
第四种：修饰class成员函数（静态成员函数），只能访问class variable
2）初始化问题  
a.全局静态变量/局部静态变量
编译阶段就已经初始化完成
b.类内静态变量  
必须在类外部定义：如果在类内初始化，会导致每个对象都包含该静态成员，并且需要在编译阶段就已经初始化完成  


## C++11 
### 1.关键字
1.NULL与nullptr  
NULL在编译时会被替换为0，因此会导致函数默认值的多义；  
nullptr仅表示空指针  
### 2.右值引用
1.值语义与对象语义（引用语义）  
1）值语义  
定义：拷贝之后与原对象没有关系，比如 int a = b， 赋值后a就是单独的值 string,vector,map  
特点：容易控制生命周期  
2）对象语义  
定义：禁止拷贝或者拷贝后通过多个引用或者指针对同一个底层地址进行操作  
特点：不容易控制生命周期，可以通过智能指针实现  
2.右值与左值  —— 根本区别在于是否允许取地址&运算符获得对应的内存地址  
1）左值  
左值是对应（refer to）内存中有确定存储地址的对象的表达式的值  
2）右值  
右值是所有不是左值的表达式的值，因而右值可以是字面量、临时对象等表达式。 **字面量和临时对象也是会申请空间**  
3.右值引用 —— 移动语义 + 完美转发  
1）移动语义（与拷贝语义相对）  
背景：用临时对象或者字面量赋值或者返回值后会自动释放，造成已经申请过的再释放一遍，可以通过移动语义将此时的资源再利用起来
a.临时对象通过一个接受右值的函数传递给另一个函数后，就会变成左值  
b.move() 将左引用转换为右引用
```c
template <class T> swap(T& a, T& b) 
{ 
    T tmp(std::move(a)); // move a to tmp 
    a = std::move(b);    // move b to a 
    b = std::move(tmp);  // move tmp to b 
} // 避免了三次拷贝
```
2）完美转发  


### 3.智能指针
用栈上对象（智能指针对象）来管理堆上对象的生存期  
