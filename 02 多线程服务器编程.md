《Linux多线程服务端编程：使用muduo C++网络库》 笔记

# 第一章 C++多线程编程
## 线程安全的对象生命期管理
### 存在问题
1.对象中的mutex成员只能保证类内数据的原子性，不能保证对象正确销毁  
2.交换时死锁——swap(a,b) swap(b,a) 同时执行  
```c
void swap(Counter &a, Counter &b)
{
    MutexLockGuard aLock(a.mutex_);
    MutexLockGuard bLock(b.mutex_);
    /// ...
}
```
3.动态创建的对象通过指针访问，无论内存上的对象是否被销毁，单从指针上并得不到答案  
### 解决方案 —— 智能指针（shared_prt/weak_ptr）  
1.简介  
shared_ptr：引用计数型 —— 可能产生循环引用  
weak_ptr::引用计数型，但是不增加对象的引用次数，像一个助手  
    .lock() // 返回一个shared_ptr 若对象已经释放则为空  
    .expired() // 检测对象是否已经被释放  
    构造shared_ptr()  
2.本质：  
使用栈上RAII技术来管理堆上资源（通过主动调用delete）  

## 线程同步精要
### 互斥器（mutex）——加锁原语
1.使用原则  
1）用RAII手法封装mutex的创建、销毁、加锁、解锁四个操作 —— 可以保证加解锁在同一个线程、不会忘记解锁、Guard是栈上对象，看调用栈就可以分析锁情况  
2）只是用非递归mutex（不可重入锁）  也即同一个线程不能重复对一个线程加锁
3）不手工调用lock()和unlock()  
4）不使用跨进程mutex，进程通信只使用TCP  
2.影响性能  
1）false sharing 伪共享  
### 条件变量 （condition variable）—— 等待原语
1.java object 内置wait() notify() notifyAll()  
2.BlockingQueue  
```c
mudou::MutexLock mutex;
mudou::Condition cond(mutex);
std::deque<int> queue;

// wait端
// wait必须与mutex一起使用，布尔表达式的保护需要mutex
int dequeue()
{
    MutexLockGuard lock(mutex);
    while (queue.empty()) // 必须使用循环，不能使用if判断，因为wait可能会被虚假唤醒 spurious wakeup
    {
        cond.wait(); // 这一步会原子 unlock mutex 并进入等待，不会与入队列死锁
        // wait() 执行完毕后会自动重新加锁
    }

    int top = queue.front();
    queue.pop_front();
    return top;
}

// signal/broadcast端
void enqueue(int x)
{
    MutexLockGuard lock(mutex);
    queue.push_back();
    cond.notify();
}
```
### 使用pThread实现锁、卫兵锁、条件变量
```c
class MutexLock : boost::noncopyable
{
public:
    MutexLock() : holder_(0) 
    {
        pthread_mutex_init(&mutex_, NULL);
    }

    ~MutexLock()
    {
        assert(holder_ == 0);
        pthread_mutex_destory(&mutex_);
    }

    bool isLockedByThisThread()
    {
        return holder_ == CurrentThread::tid();
    }

    friend class MutexLockGuard;

private:
    void lock()
    {
        pthread_mutex_lock(&mutex_);
        holder_ = CurrentThread::tid();
    }

    void unlock()
    {
        holder_ = 0;
        pthread_mutex_unlock(&mutex_);
    }

    pthread_mutex_t* getPthreadMutex()
    {
        return &mutex_;
    }

private:
    pthread_mutex_t mutex_;
    pid_t holder_; 
};

class MutexLockGuard : boot::noncopyable
{
public::
    explicit MutexLockGuard(MutexLock& mutex) : mutex_(mutex)
    {
        mutex_.lock();
    }

    ~MutexLockGuard()
    {
        mutex_.unlock();
    }
};
```
## 多线程服务器的适应场景与常用编程模型
### 单线程常用编程模型
1.Reactor：non-blocking io + IO multiplexing  
程序基本结构为：事件循环 + 事件驱动 + 事件回调  
```c
	while (!done)
	{
		int timeout_ms = max(1000, getNextTimeCallback());
		int retval = ::poll(fds, nfds, timeout_ms);
		if (retval < 0)
		{
			// 处理错误，回调用户的error handler
		}
		else
		{
			// 处理到期的 timers，回调用户的timer handler
			if (retval > 0)
			{
				// 处理IO事件，回调用户的IO event handle
			}
		}
	}
```
### 多线程常用编程模型
1.Reactor  
2.线程池  
使用任务队列实现 或 BlockingQueue  

### 进程间通信只用TCP
### 线程分类
1.IO线程  
主循环是IO multiplexing，阻塞等在select/poll/epoll_wait系统调用上  
2.计算线程  
主循环是blocking queue，阻塞等在condtition variable上，一般位于thread pool，尽量避免阻塞  
3、第三方库线程  
logging、database connection  



# 第二章 muduo网络库
