# 数据库基础  
## 事务  
### 四大特性（ACID）  
1.原子性  
事务是一个不可分割的工作单位  
2.一致性  
事务必须使数据库从一个状态转换为另一个一致性状态  
3.隔离性  
多个用户并发访问数据库时，数据库为每个用户开启一个事务  
4.持久性  
事务提交后的修改永久生效  
### 事务的隔离级别
1.隔离级别出现的背景  
1）脏读
一个事务读取了另一个没有提交事务的数据  
2）不可重复读  
读取了前一个事务提交的数据（连续查询但是读取的数据不相同） 
3）幻读  
与不可重复读差不多，不同在于幻读针对的是一批数据整体（当一个数据修改某一列都从1到2，事务还没被提交之前，另一个事务插入了一条1的数据，此时会产生幻读）  
2.隔离级别  
1）read uncommit 读，未提交  
允许读取未提交数据  
什么都不能保证   
2）read commit 读，提交（orcale默认）  
只允许读已提交数据  
避免脏读  
3）repeatable read 重复读  
在一个事务中，对同一个项，前后两次读取的结果一样  
避免脏读、不可重复读（mysql默认）  
4）serializable 序列化  
保证可串行化读取  
可避免脏读、不可重复读、幻读  
用锁实现   

## 数据库引擎  
### InnoDB  
支持事务  
适合密集更新  
MySQL默认  
### MyISAM  
不支持事务  
适合密集选择  
独立于操作系统  

## 索引  
### B树与B+树  
B树：结点上既为数据又可以充当索引  
B+树：非叶子结点上不存储数据，只存储索引，只有在叶子结点上存储数据，这样可以存储更多的索引，使树更矮  
B树结构的优势：减少读取次数，减少磁盘I/O  

## 三范式  
### 第一范式  
每个属性都不能再分割  

### 第二范式  
消除了非主属性对码的部分函数依赖  
例： 学号 姓名 课程名    
（学号、姓名） -> 课程名 // 学号和姓名共同构成码  
（姓名） -> 课程名  // 姓名也可以单独成为码  
### 第三范式  
消除了非主属性对码的传递函数依赖  
例：  
(学号) -> 姓名  
姓名 -> 课程名  // 非主属性姓名也可以推出课程名  


# mysql日志类型
重做日志：  
保持实务的持久性，方式发生故障时，尚有脏页未写入磁盘，再重启服务后，可以根据日志重做，从而达到持久性特性  
回滚日志：  
保存了事务发生之前的数据的一个版本，可以用于回滚  
二进制日志：  
用于主从复制中，从库利用主库上二进制日志进行重播，实现主从同步  
以上三个与事务操作有关  
错误日志、慢查询日志、一般查询日志、中继日志  

# SQL语法
## 注释
```sql
# 注释
SELECT *
FROM mytable; -- 注释
/* 注释1
   注释2 */
```
## 针对表的操作
### 创建表   
```sql
create table name... 
```
### 修改表  
```sql
增加属性（列）：
alter table name... add colname... char(20) 
删除属性：
alter table name... drop column colname... 
```
### 删除表  
```sql
drop table name...
```
## 针对内容的操作
### 增
``` sql
insert into tablename...(cloname..., cloname...)
value(val1, val2);
```
### 删
```sql
delete from tablename... 
where id = 1;// 删除一行
```
### 改
```sql
update tablename... 
set value = 1
where id = 1
```
### 查
``` sql
select * from tablename... where ..
select distinct value1 form tablename... // 去掉重复的
select vaule1 form tablename... limit 2,3 // 返回从index=2开始的总共3个数字
```

# 图数据库
## 图数据库的存储结构
节点：图中对象 + 可带若干值属性 + 可带标签    
关系：连接节点 + 可带若干值属性  

## neo4j
### 基本操作
```sql
CREATE (n:Person { name: 'Andres', title: 'Developer' }) return n;
CREATE (n:Person { name: 'Vic', title: 'Developer' }) return n;
match(n:Person{name:"Vic"}),(m:Person{name:"Andres"}) create (n)-[r:Friend]->(m) return r;
match(n:Person{name:"Vic"}),(m:Person{name:"Andres"}) create (n)<-[r:Friend]-(m) return r;
```
