
# 图

## 表示方法

### 邻接矩阵

```c
vector<vector<int>> grap;
```

### 邻接链表

```c
map<string, multiset<string>> grap;
map<string, list<string>> grap;
```

## 图算法

### DFS

1.非递归  
使用stack

```c
while(栈S非空)
    x=栈S的顶元素(不出栈)；
    if(存在并找到未被访问的x的邻接点w) // 或者是邻接链表找不到节点
        访问w；visited[w]=1；
        w进栈;
    else
        x出栈；

while (!stack.empty())
{
    string currNode = stack.top();
    if (!graph[currNode].empty())
    {
        stack.push(*graph[currNode].begin());
        graph[currNode].erase(graph[currNode].begin());
    }
    else
    {
        res.insert(res.begin(), currNode);
        stack.pop();
    }
}
```

2.递归  

```c
void dfs(map<string, multiset<string>>& grap, string &currNode)
{
    while (!grap[currNode].empty())
    {
        string nextNode = *grap[currNode].begin();
        grap[currNode].earse(grap[currNode].begin());
        dfs(grap, nextNode);
    }

    res.push_back(currNode);
}

void dfs(vector<vector<int>>& grap, vector<vector<int>>& visted, int from)
{
    for (int i = from; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grap[i][j] && visted[i][j] == false)
            {
                visted[i][j] = true;
                dfs();
            }
        }
    }
}
```

### BFS

1.非递归  
使用队列，类似于树的层序遍历  

### A*

### Dijkstra

使用最小堆  

## 图计算

### 基础数据结构

G = (V, E, D) (vertex\ edge\ data)  
