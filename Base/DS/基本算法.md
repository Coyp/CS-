# sort

## quick sort

```c++
// 此版本减少了把最后换回中间的操作
int pivot = arr[end];
int first = 0;
int last = arr.size();

while (true) {
    while (arr[first] < pivot) first++;
    last--;
    while (pivot < arr[last]) last--;
    if (!(first < last)) break;
    std::swap(arr[first], arr[last]);
    first++;
}
交错, 跳出循环后
last 指向 L 的最后一个值
first 指向 R 的开头
```

# 动态规划

## 框架

1 状态 -> 写出状态转移  
2 选择 -> 遍历选择

## 复杂度
动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。
