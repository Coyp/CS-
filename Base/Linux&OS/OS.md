# 操作系统基础  

## 一.内存管理  

### 页表

1.定义：  
存放在物理内存中的数据结构，记录了虚拟页与物理页的映射关系  

### 虚拟内存
1.定义：  
虚拟地址由程序生成，CPU需要将虚拟地址翻译成物理地址才能访问到数据，虚拟地址对于程序来说，让程序有一个连续的、巨大的地址空间  
2.基本原理  
虚拟地址 = 页号 + 偏移位
使用位：记录是否被使用  
脏位：若脏位被标记，说明内存中被更改，那么被置换时，需要将值写回内存，若没被标记，则可以直接丢弃  
![](picture/memory_change.png)

### 内存页面置换算法  
1.场景  
当缺页时，操作系统接手从下级存储中寻找页  
2.算法  
1）FIFO先进先出：置换先进来的页面  
2）LRU 最近最久未使用：置换最长时间没被引用的页面  
3）LFU 最不常用：置换访问次数最少的页面  

## 二.进程管理
### 进程调度算法
暂无  
### 进程之间同步
1.临界区  
2.同步与互斥  
3.信号量    
4.管程  
**同步与通信的区别：为了达到进程间同步的目的，进而需要进程间的通信**  
### 进程之间通信
1.管道  
1）特点  
a. 用于具有血缘关系的进程之间的通信（父子进程或者兄弟进程）  
2）例子  
a. linux中 | 命令  或 
```c
pipe()创建
#include <unistd.h>
int pipe(int fd[2]);
```
![](picture/process_relationship.png)  
2.命名管道（FIFO）  
1）特点  
a. 去除了只能在父子进程中使用的限制 
b.以一种特殊设备文件形式存在于文件系统中（很类似于文件的操作，write/open等等）  
2）例子  
![](picture/FIFO.png)  
3.消息队列  
消息的链接表，存放在内核中，一个消息队列由一个标识符（队列ID）来标识  
1）相比于FIFO    
a.**独立于发送与接收进程，**进程终止时，消息队列及其内容并不会被删除     
4.共享内存  
两个或者多个进程共享一个给定的存储区域  
1）信号量与共享内存通常结合在一起使用，信号量用来同步对共享内存的访问  
5.信号量   
是一个计数器，信号量用于实现进程之间的互斥与同步，而不是用于存储进程间的通信数据   
6.套接字  
还可以用于不同机器间的通信  
总结  
1）管道：速度慢，容量有限，只有父子进程能通讯      
2）FIFO：任何进程间都能通讯，但速度慢      
3）消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题（因为独立于读写进程）      
4）信号量：不能传递复杂消息，只能用来同步      
5）共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存  
### 父子进程
1.定义  
1) fork()   
通过复制父进程来创建一个新的进程（子进程）
// pid = fork() 子进程会返回0， 父进程会返回子进程的pid
2) exec()  用于让子进程执行自己的程序  
执行  
3) wait()  
主进程阻塞等待子进程结束，若子进程结束返回子进程的pid，并销毁子进程号  

2.特点  
1）fork后会产生两个进程，子进程有其唯一的PID  
2）fork后子进程的代码段、数据段、堆栈区和父进程一模一样（即创建时直接映射到父进程的物理地址）  
3）当主进程和子进程有改变的时候，才开始分配新的栈、堆和数据段  
4）当执行exec后将子进程的代码段进行替换 

3.孤儿进程  
当父进程退出后，它的子进程还在运行，那么子进程会变成孤儿进程，孤儿进程会被init（进程号为1）所收养，并由init进程对它们完成状态收集工作  

4.僵尸进程  
一个进程fork创建子进程，如果子进程退出，而父进程没有调用wait或者waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中（因为父进程需要调用后知道子进程的终止状态）  

### 死锁  

#### 必要条件  

1.互斥：每个资源要么已经分配给一个进程，要么是可用的；    
2.占有和等待：已经有资源的进程可以再请求新资源；  
3.不可抢占：已经分配的资源不能被抢占，只能由该进程自己释放；  
4.环路等待：两个或者两个以上进程组成一个环路，每个进程都在等待下一个进程所占的资源；

#### 处理方法
1.鸵鸟政策  
解决死锁代价很高，不采取任何措施  
2.死锁检测与死锁恢复  
检测：深搜，若有环则为死锁  
恢复：抢占、回滚、杀进程  
3.死锁预防  —— 破坏必要条件  
4.死锁避免  
1）两个线程互相等待：1号持有A，并且获得B后才会释放A，2号持有B，并且获得A后才会释放B，双方等待
1(A) -> B  
2(B) -> A  
解决方法：超时机制，若1号等待B超过一段时间后，放弃获取并释放A  
2）产生上述两个线程互相等待的可能性场景：
两个地方的加锁解锁顺序不一致  
LockA     LockB  
LockB     LockA  
unLockB   unLockB  
unlockA   unLockA  
解决方法：代码每处的加解锁顺序相同（所以可以根据啥写个排序？）
### 线程管理
#### 基本知识
1.线程的生命周期及状态转换  
![](picture/thread.png)  
创建：new  
就绪：start( ) //  
运行：run( ) //其中包含了这个线程的内容（程序体）、若run中代码执行完毕则线程结束、若直接调用run方法只是调用一个方法而已，程序中仍然只有一个主线程  
阻塞：wait/sleep/join等  
https://blog.csdn.net/asdf_1024/article/details/78978437  
#### 多线程编程
1.java多线程编程  
<http://www.cnblogs.com/PerkinsZhu/p/7242247.html>  
1）java提供的锁  
synchronized锁 JVM层锁 隐式的获取锁  
reentranLock锁 JDK层锁 lock trylock unlock  
2.C++多线程编程 （C++11）  
<https://github.com/forhappy/Cplusplus-Concurrency-In-Practice>
#### 锁知识（包括一些数据库中的锁）  
1）  
共享锁：读操作时，多个线程只要申请过共享锁既可读取  
排它锁：只允许单个线程进行操作  
2）  
乐观锁：读不需要上锁，写的时候进行是否脏位的判断  
悲观锁：读和写都要上锁  
3）  
可重入锁：若线程已经获取锁，该线程在另一个地方又需要获取相同的一把锁，此时可以直接获取（采用引用计数）    
不可重入锁：若线程已经获取锁，重新获得锁之前必须释放资源  
4）  
公平锁：等待线程按照请求锁的先后顺序分别获取锁  
非公平锁：等待线程获取锁的顺序和请求先后无关，可能随机获取或者按照某种规则获取  
5）  
自旋锁：请求锁等待时，不进行wait挂起，不释放cpu资源，持续执行while  
非自旋锁：锁等待时，会释放CPU资源，多用sleep、wait、CPU中断等方式  
5.future 模型  
因为在多线程中使用全局变量比较危险，因此可以用future存储当前的结果给未来使用  
#### 线程间通信
为了进程中的多个线程协同工作，因此需要手段进行线程之间的同步  
1.Java中的线程通信方法  
1）wait和notify/notifyall ——Object的方法  
wait：挂起等待，放弃锁  
区别：  
notify：从锁的等待池随机唤醒一个线程到锁池
notifyAll：从锁的等待池唤醒所有的线程到锁池竞争锁，若竞争不到则继续留在锁池
2）await和signal/signalAll —— Condition的方法  
Conditon.awati( )：挂起等待，放弃锁  
Conditon.signal( )：唤醒  
3）sleep/yield/join  
sleep：让当前线程暂停一段时间，时间到后自动唤醒，期间不会释放任何持有的锁  
yield：当前线程从运行状态转换为就绪状态，由线程调度重新选择就绪状态的线程分配资源  
join：暂停当前线程（并不会释放锁），等待被调用线程指向结束后再继续执行（实际上使用了自旋锁）  
4）信号量  
Semaphore  
同进程概念，提供了控制同时访问临界区资源的线程个数  

# 三.I/O模型   
https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md  
## 操作  
一个输入操作包括两个阶段：等待数据准备好、从内核向进程复制数据  
具体：  
1.等待数据从网络中到达，当数据到达时，复制到内核中的某个缓冲区；  
2.将数据从内核缓冲区复制到应用进程缓冲区  
## I/O模型  
### 1.阻塞I/O  
1）应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回  
2）cpu利用率比较高  
3）recvfrom()  // 用于接收Socket传来的数据  
### 2.非阻塞I/O（轮询）  
1）应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行    
2）内核一直在处理系统调用，cpu利用率低  
### 3.I/O复用  
1）通过系统函数selete/poll/epoll来监听多个套接字，阻塞在系统函数上面，当某一个套接字可读时，再使用recvfrom将数据从内核复制到进程中  
2）与阻塞I/O的区别就是先使用selete等获取一个可读套接字  
### 4.信号驱动I/O  
1）应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，当数据达到时，内核向应用进程发送sigio信号，然后调用recvform获取  
### 5.异步I/O  
1）aio_read系统调用会立即返回，应用程序继续执行不被阻塞，内核完成操作后向应用程序发送信号  
2）与信号驱动I/O的区别：异步I/O是通知应用进程I/O完成，信号驱动I/O是通知应用进程可以开始I/O  
## I/O复用  
### select  
#### 函数  
```c
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```  
readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合;  
fd_set 使用**数组**实现，数组大小使用 FD_SETSIZE 定义;  
timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout;  
成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0  
### poll  
#### 函数  
```c
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```
plllfd使用链表实现  
#### 比较   
1.功能：select使用数组实现，默认大小为1024，只能监听1024个描述符，而poll使用链表，没有描述符数量的限制  
2.速度：都比较慢  
1）**每次调用**都需要将全部描述符从应用进程缓冲区复制到内核缓冲区 —— 因此更新描述符通过直接修改即可  
2）返回结果中没有声明哪个描述符已经准备好，需要轮询的方式来找到I/O完成的描述符  

### epoll  
#### 函数  
```c
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```
epoll_ctl()：用于向内核注册新的描述符或者是改变某个文件描述符的状态 —— 因为描述符保存在内核中，需要额外的函数进行修改    
epoll_wait()：已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符  
epoll_event：ctl时可以加入单个或者多个event，wait时也是使用event拿到已经准备好的描述符
#### 工作方式  
1.LT （level trigger） —— 默认  
当检测到描述符到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用eppll_wait会再次通知  
2.ET （edge trigger） 
与LT不同的是，通知后要立即处理，否则下次调用不会得到事件到达的通知  
### 应用场景  
#### 1.select场景  
timeout精度为1ns，而其他俩为1ms，因此适合实时性要求更高的场景  
可移植性高，支持所有的平台  
#### 2.poll场景  
同时监控小于1000个，没必要使用epoll  
监控的描述符状态变化多，并且是短暂的，没必要使用epoll，因为epoll的所有描述符都存储在内核中，如果要改变必须调用epoll_ctl系统调用，会降低效率  
#### 3.epoll场景  
在linux平台上，非常大量的描述符需要同时轮询，最好是长连接

## 四.链接  
https://wdxtub.com/2016/04/16/thin-csapp-4/
### 预处理阶段
1.功能  
处理以#开头的预处理命令  
### 编译阶段
1.功能  
翻译成汇编语言  
### 汇编阶段
1.功能  
汇编语言翻译成可重定向目标文件  
2.目标文件组成  
ELF  
.line 源程序中行号和.text节中指令的映射  
.text 已编译的机器代码  
.rodate 只读数据  
.data 已初始化的全局变量  
.bss 未初始化的全局变量  
.symtab 符号表  
.debug 调试符号表，包括局部变量定义  
（下面地址更大）  
1）数据段  
程序中用到的全局变量或者静态数据，一般是可读，可写，可执行  
2）代码段  
程序的指令，一般是可读和可执行的，但一般不可写  
3.目标文件分类  
汇编产生的目标文件包括代码段和数据段两部分，其中代码段包括程序执行的指令(.text)，数据段包括全局/静态变量(.data 初始化的全局量/.bss未初始化的全局量)（此时已经完成内存分配）   
可执行目标文件：直接在内存中执行  
可重定向目标文件：与其他可重定向目标文件在链接阶段合并，创建一个可执行目标文件  
共享目标文件：特殊的可重定向目标文件，在运行时动态加载进内存并链接  
4.bss与.data的区别  
.data 非零初始化过的全局变量，占文件大小，占运行时内存大小    
.bss 零初始化或者未初始化的全局变量，不占文件大小，占运行时内存大小  
因为bss里面的值都会默认位0，因此可以优化不存储具体的值   
### 链接阶段
1.功能  
将可重定向目标文件（.o）文件进行合并（合并同类项放在一起，并重新分配内存），生成可执行文件    
2.链接分类  
1）静态链接  
一组可重定向目标文件为输入，完全链接的可执行目标文件为输出，期间完成两个任务：  
符号解析：将每个符号（每个符号对应一个函数或全局变量或者静态变量）引用与一个符号定义关联起来  
重定位：将每个符号定义与一个内存位置关联起来，然后修改每个符号引用，使得指向这个内存位置  
2）动态链接 dll/.so  
链接器阶段：动态库的重定位信息和符号表信息，而没有具体的代码和数据    
运行时可执行目标文件 + 动态链接器 **（.so 代码和数据）** = 执行文件  
### 加载
1.将可执行文件的代码段和数据段拷贝到内存中的过程叫做加载，之后会跳转到第一条指令或者入口点来运行程序  
2.内核虚拟内存  
用户栈（运行时创建）  -> %rsp栈指针  
共享库内存映射区  
运行堆（malloc创建）  
读/写数据段（.data, .bss）  
只读代码段（.init, .text, .rodata）  
（下面地址更小）  
3.过程  
通过加载器，加载到内存，供CPU调用运行  
### 编译相关问题
1.static 静态变量存在哪里？  
静态变量与全局变量存放位置相同  
2.常量包括哪些？
```c
const int b = 1;  // readonly
const string c = "123";
int main()
{
    char* p = “Hello World”; // 常量，不能修改
    char a[] = “Hello World”; // 非常量，运行时存入数组
    // Hello World 都是常量，但是p是指向了常量，因此不能修改，而a运行时存入了数组，因此可以被修改
    const int a = 1;
}
```



# Linux相关  
## 链接  
1.硬链接  
定义：一个innode号有多个文件名  
用法：link/ln oldfile newfile  
特点：  
a.删除一个文件，不影响其他文件  
b.只能链接已经存在的文件（不是目录）  
2.软连接（符号链接）  
定义：一个文件的data中保存了指向另一个文件的路径  
用法：ln -s   
特点：  
a.软链接有自己的属性和权限等  
b.可以对不存在的文件或者目录进行创建  
c.删除软连接不会删除原始文件，而删除原始文件会导致软链接失效  
## linux下内存分析
Linux系统在内存分配上：内存充足时，尽量使用内存来缓存一些文件，从而加快进程的运行速度，而当内存不足时，会通过相应的内存回收策略收回cache内存，供进程使用  
### 系统整体使用
1.top  
2.free -m 可以看到简单的使用情况  
3./proc/meminfo 详细信息  
### 进程
/proc ：系统内核的映像  
1.cat /proc/pid/smaps 内存详细信息  
2.cat /proc/pid/status 进程的整体信息  
## 其他  
1.写时复制  
1）定义：多个调用者同时请求相同的资源，会共同获得相同的指针指向相同的资源，当某个调用者试图修改资源内容时，系统才会真正复制一份副本给修改者进行修改，其他调用者资源仍然不变  
2）应用  
a.fork()后的子进程与主进程共享同一份资源，执行exec后才会给子进程分配空间    
b.string中允许写时复制，C++11中取消了  


