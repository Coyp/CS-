# 2 线程管理基础
1.启动  
std::thread对象创建(为线程指定任务)时启动  
2.停止  
myThread.detach() // 不等待线程结束（线程仍然在执行中）
myThread.join() // 等待线程结束

# 3-7
## 例子
 - 使用锁实现队列  
 - 使用条件信号量实现队列  
 - 使用锁实现并发map   
 - 使用原子变量实现自旋锁  
 
# 8.并发代码设计
## 8.2 影响并发代码的因素
1.原理  
 - 理解多核cpu的缓存：每个核的l1缓存至少是独立的 
 - 缓存的最小单位是行，而不是字节  

2.现象  
 - 伪共享：线程1和线程2都缓存了同一行的X和Y，线程1修改X，会导致使用Y的线程2的缓存失效，重新读取  
 - 乒乓缓存：缓存并使用同一个值，任何一个修改都会导致其他线程重新缓存，需要加上volatile  
 
