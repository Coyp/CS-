# 常见应用

## 注意

- head.Next = xx // 这是改变
- head = head.Next // 这是赋值

## 增删类

1. 有可能只有一个节点, 因此需要构造头空指针指向链表, 便于删除头或者插入头  

## 两链表相交并求交点

- 判断相交: A 的尾连到 B 的头上, 然后开始遍历 B, 若能回来说明相交
- 求交点:
  - 1.求出两个链表的长度, 作差值, 然后一个先走
  - 2.hash, 既然不能一个一个比较, 可以利用 hash 先存起来
  - 3.双指针, A + C 与 B + C -> A + B + 2C -> 第一个指针先走 A+C, 走完再走 B+C, 同理第二个指针
- 循环判断条件 while (headA != headB) {} // 若不相交, 那么最后都为 nullptr, 若相交则为相交点

## 判断是否有环

- 快慢指针

## 求环形链表的入口

- slow -> a + b (b 指在环入口顺时针到第一次相遇的长度)
- fast -> a + b + c + b (c指 从 b 顺时针到入口的长度)
- (a + b) * 2 = a + b + c + b -> a = c
- 因此先 fast 以 2 倍走, slow 以 1 倍走, 第一次相遇后, fast 从开头重新以 1 倍速走, 最终会在入口相遇

## 求中点

- 快慢指针

```c
// 产生的中点是 slow -> 1 2(slow) 3 / 1 2 3(slow) 4
ListNode *pre = head;
ListNode *slow = head;
ListNode *fast = head;
while (fast != NULL && fast->next != NULL) { //
  pre = slow;
  slow = slow->next;
  fast = fast->next->next;
}
// 分割两段
// 1 // 2 3
// 1 2 // 3 4
if (pre != nullptr) pre->next = nullptr;
return slow
// 此刻, right的一部分总是携带中间节点
```

## 链表反转

```c
ListNode *pre = nullptr;
while (head != NULL) {
  ListNode* next = head->next;
  head->next = pre;
  pre = head;
  head = next;
}
return pre;
```

## 节点接力

- 328.奇偶链表

    ```go
    for even != nil && even.Next != nil {
      odd.Next = even.Next
      odd = odd.Next
      even.Next = odd.Next
      even = even.Next
    }
    ```

- 143.重排链表

## 总结

1. while (head && head->next && head->next->next) // 若判断 next->next 则需要先判断 前面的

## 测试

1. 使用 1 个节点代入
2. 使用 2 个节点代入
3. 代入例子