# 队列

## 智能指针实现

```c++
template<typename T>
class queue
{
private:
  struct node
  {
    T data;
    std::unique_ptr<node> next;

    node(T data_):
    data(std::move(data_))
    {}
  };

  std::unique_ptr<node> head;  // 1
  node* tail;  // 2

public:
  queue()
  {}
  queue(const queue& other)=delete;
  queue& operator=(const queue& other)=delete;
  std::shared_ptr<T> try_pop()
  {
    if(!head)
    {
      return std::shared_ptr<T>();
    }
    std::shared_ptr<T> const res(
      std::make_shared<T>(std::move(head->data)));
    std::unique_ptr<node> const old_head=std::move(head); // 不能直接赋值head，而是先把它上面的指针转移走才可以
    head=std::move(old_head->next);  // 3
    return res;
  }

  void push(T new_value)
  {
    std::unique_ptr<node> p(new node(std::move(new_value)));
    node* const new_tail=p.get();
    if(tail)
    {
      tail->next=std::move(p);  // 4
    }
    else
    {
      head=std::move(p);  // 5
    }
    tail=new_tail;  // 6
  }
};
```

## 相关题目

### 基本操作

1. leetcode
    - 225.队列实现栈 (两个队列, 其中一个负责加入, 一个负责出)

### 单调队列 双端队列 (deque)

1. leetcode
    - 239.滑动窗口最大值 (设计最大队列, 加上双端队列, 头始终保持为窗口内的最大值, 通过从后面比较进行更新)

    ```c++
    for (int i = 0; i < nums.size(); i++) {
      // 先清理 从后面放, 把大的留下来
      while (!d.empty() && d.back() < nums[i]) {
        d.pop_back();
      }
      d.push_back(nums[i]);

      // i >= k, 清除队列头的值
      if (i >= k && nums[i-k] == d.front()) {
        d.pop_front();
      }

      if (i >= k - 1) {
        res.push_back(d.front());
      }
    ```
