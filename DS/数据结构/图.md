
# 图

## 表示方法

<https://visualgo.net/zh/graphds>

### 邻接矩阵

```c
vector<vector<int>> grap;
list<list<int>> 
```

### 邻接链表

```c
map<string, multiset<string>> grap;
map<string, list<string>> grap;
```

### 边缘列表

- 把每条边表示起来

## 图算法

### DFS

1.非递归  
使用stack

```c
while(栈S非空)
    x=栈S的顶元素(不出栈)；
    if(存在并找到未被访问的x的邻接点w) // 或者是邻接链表找不到节点
        访问w；visited[w]=1；
        w进栈;
    else
        x出栈；

while (!stack.empty())
{
    string currNode = stack.top();
    if (!graph[currNode].empty())
    {
        stack.push(*graph[currNode].begin());
        graph[currNode].erase(graph[currNode].begin());
    }
    else
    {
        res.insert(res.begin(), currNode);
        stack.pop();
    }
}
```

2.递归  

```c
// node 才是主体, graph 只是信息
void dfs(vector<vector<int>>& graph, vector<int>& visited, int node) {
  for (int j = 0; j < n; j++) {
    if (graph[node][j] && visited[j] == false) {
        visited[j] = true;
        dfs(graph, visited, j);
    }
  }
}
```

### BFS

1.非递归  
使用队列，类似于树的层序遍历  

### A*

### 拓扑排序

- 入度即为某个节点的边数, 因此使用边缘列表比较好
- 依次删去入度为 0 的节点

### Dijkstra

- 维护一个所有节点到终点距离为无穷的表
- 找到其中最小值根据邻接矩阵更新值
- 直至全部遍历完全
- 此时表为从出发点到各个节点的最小距离

## 图计算

### 基础数据结构

G = (V, E, D) (vertex\ edge\ data)  
