
# 树

## 基本

![avatar](tree_terms.png)

## 二叉树分类

(定义越来越严格)  

- 平衡二叉树：高度差不超过1 + 搜索树  
- 满二叉树：除叶子节点外，其余节点都有两个子节点  
- 完全二叉树：0 ~ h-1层都是满节点 + h层节点从最左开始，可以不满  
- 完美二叉树：所有层节点都是满的  

## 二叉搜索树

特性  
1. 中序遍历后的序列是递增排序序列
2. successor(后继节点): 中序遍历下一个节点, 比当前节点大的最小节点, 即取当前节点的右节点, 然后一直取左节点
3. predecessor (前驱节点): 上一个节点, 比当前节点大, 即取当前节点的左节点, 然后一直取右节点
![avatar](tree_search.png)

删除操作
```c++
deleteNode->left == nullptr && deleteNode->right == nullptr // 直接删除
deleteNode->left == nullptr || deleteNode->right == nullptr // 直接用存在的右或者左子树代替 
deleteNode->left != nullptr && deleteNode->right == nullptr // 找到前驱节点代替or后继代替
```

滑动窗口 -> map/ set

- 可以做到 logn 时间查找, 删除, 插入
- 滑动窗口内的值有序
  - std::set::lower_bound(x) ->  返回 >= x 的最小值
- 删除 -> earse(nums[i-k])


## 平衡二叉搜索树

保持整体深度为 O(logN)  
查找/ 增加/ 删除 效率 O(logN)

- AVL树
  - 遵循左右子树高度差为 1
- 红黑树
  - 根据红黑的一定规则
- 对比 红黑树比AVL树的优势？  
  - AVL严格按照平衡二叉树去旋转，可能会导致更多旋转操作；  
  - 红黑树牺牲了一定的平衡性，旋转次数不超过3次的条件下保持一个合理的高度

## B树

### B树

1.使用B树作为索引树的原因  
虽然红黑树的查找效率更好，但是由于内存读取的局部性，红黑树节点的实际物理地址离得比较远，导致频繁从磁盘读取，影响速度  
而B树将节点按顺序放在一起，并且起到了索引的作用，减少了向磁盘的读取  

### B+树

1.优点  
1）非叶子节点只存储索引，不存储数据，进而能存储更多的索引  
2）数据都在叶子节点上，并且通过链表相连接，因此可以扫库，通过链表一次读取所有

## LSM 树

1.背景  

- 顺序写磁盘快于随机写至少三个数量级, 因此数据添加到文件, 此时数据可以完全顺序
- 对读有好的方法: 二分/哈希/B+树等都以某种结构放置, 导致影响了写效率

2.定义

- 牺牲了部分读性能, 而保证超高写性能 -> 本质是所有操作顺序化
- 修改增量保持在内存(memtable)中, 达到指定限制后将这些修改操作批量写入磁盘(sstable)中

## 前缀树(trie树)

1.优点  

- 相比哈希可以找到同一前缀的全部键值
- 按字典序枚举字符串的数据集

2.实现

```c++
struct TrieNode {
    vector<TrieNode*> layer; // 0 - 26 个字母版本
    unordered_map<char, TrieNode*> layer; // 通用版本   
    bool isWord = false;
}
```

## 应用

### 求树的高度

```c
int getDepth(TreeNode* root)
{
    if (root == NULL) return 0;
    return max(getDepth(root->left), getDepth(root->right)) + 1;
}

//
int GetTreeDepth(BinaryTreeNode root)
{
    if (root == null)
    {
        return 0;
    }

    int left = GetTreeDepth(root.LeftChild);
    int right = GetTreeDepth(root.RightChild);

    return left >= right ? left + 1 : right + 1;
}

```

### 数的遍历

#### 前序遍历

```c
void preFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
 
        std::cout << root->val << endl;
        preFindNode(root->left);
        preFindNode(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                cout << root->val << endl;
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                treeStack.pop();
                root = root->right;
            }
        }
    }
```

#### 中序遍历 -> 与二叉搜索树紧密连接

```c
// 遍历
    void inorder(TreeNode *root)
    {
        if (root == nullptr) return;
        inorder(root->left);
        std::cout << root->val << endl;
        inorder(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                cout << root->val << endl;
                treeStack.pop();
                root = root->right;
            }
        }
    }

// 转成环形双向链表
void inorder(TreeNode* node, TreeNode*& pre, TreeNode*& head) { // 注意在递归中取最下面的值可以使用引用
    if (node == nullptr) return;
    inorder(node.left, pre, head);

    // 找到头, 最左节点
    if (head == nullptr) {
        head = node;
        pre = node;
    } else {
        pre->right = node; // 前面的节点只放右边
        node->left = pre;
        pre = node;
    }

    inorder(node.right, pre, head);
}
```

#### 后序遍历

```c
    void tailFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
        tailFindNode(root->left);
        tailFindNode(root->right);
        std::cout << root->val << endl;
 
        // 非递归版 利用双栈实现
        stack<TreeNode*> treeStack1;
        stack<TreeNode*> treeStack2;
 
        treeStack1.push(root);
        while (!treeStack1.empty())
        {
            root = treeStack1.top();
            treeStack1.pop();
 
            treeStack2.push(root);
            if (root->left)
            {
                treeStack1.push(root->left);
            }
 
            if (root->right)
            {
                treeStack1.push(root->right);
            }
        }
 
        while (!treeStack2.empty())
        {
            TreeNode *tmp = treeStack2.top();
            treeStack2.pop();
            cout << tmp->val << endl;
        }
    }

```