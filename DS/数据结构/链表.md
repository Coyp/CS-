# 常见应用

## 增删类

1. 有可能只有一个节点, 因此需要构造头空指针指向链表, 便于删除头或者插入头  

## 两链表相交并求交点

- 判断相交: A 的尾连到 B 的头上, 然后开始遍历 B, 若能回来说明相交
- 求交点:
  - 1.求出两个链表的长度, 作差值, 然后一个先走
  - 2.hash, 既然不能一个一个比较, 可以利用 hash 先存起来
  - 3.双指针, A + C 与 B + C -> A + B + 2C -> 第一个指针先走 A+C, 走完再走 B+C, 同理第二个指针


## 判断是否有环

- 快慢指针

## 求环形链表的入口

- slow -> a + b (b 指在环入口顺时针到第一次相遇的长度)
- fast -> a + b + c + b (c指 从 b 顺时针到入口的长度)
- (a + b) * 2 = a + b + c + b -> a = c
- 因此先 fast 以 2 倍走, slow 以 1 倍走, 第一次相遇后, fast 从开头重新以 1 倍速走, 最终会在入口相遇

## 求中点

- 快慢指针

```c
// 产生的中点是 slow -> 1 2(slow) 3 / 1 2(slow) 3 4
ListNode *fast = head;
ListNode *slow = head;
while (fast->next != NULL && fast->next->next != NULL) { // 有两种 next, 因此需要判断两种 而且是并集关系
  fast = fast->next->next;
  slow = slow->next;
}
```

## 链表反转

```c
ListNode *next = head->next;
ListNode *pre = nullptr;
while (head->next != NULL) {
  head->next = pre;
  pre = head;
  head = next;
  next = head->next;
}

head->next = pre;
```