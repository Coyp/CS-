# 动态规划

- 特点: 求最优解, 并且该问题可以分为多个子问题
- 目的: 解决子问题重复计算问题

## 框架

1 状态 -> 写出状态转移  
2 选择 -> 遍历选择

## 复杂度

动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。

## 题

### 字符串

1. 通配符匹配 (?一个字符, *零个或者多个)
    - dp[0][0] = true && dp[0][i] = dp[0][i-1] && p[i] == '*'
    - s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
    - p[j] == '*' -> dp[i][j] = dp[i-1][j](abc a\* 多个, 只要\* 前匹配即可) || dp[i][j-1](abc abc\* 零个\*)

2. 正则表达式匹配 (?一个字符, *前面的任意多个) 
    - 与上面的区别在于, x*, x 可以是不相同的, 而上面前面的已经是相同的
    - s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
    - p[j] == '*' -> 若想 p[j] = s[i] 那么必须要\*前面的数字等于 s[i] 才可以
      - p[j-1] == '?' || s[i] == p[j-1] -> dp[i][j] = dp[i-1][j] || dp[i][j-2]
        - 后面已经匹配, 只需要考虑前面是否匹配即可
        - 1 没有匹配 -> dp[i][j-2] -> abcb abcbb*
        - 2 一个字符 -> dp[i][j-1] -> abcb abcb*
        - 3 多个字符 -> dp[i-1][j] -> abcbb abcb* -> 删除 s 的
      - p[j-1] != '?' && s[i] != p[j-1] -> dp[i][j] = dp[i][j-2] 
        - \*为零 -> abc / abcd\* -> d != c -> 删除 c\*

139.单词拆分

```go
// 字符串的循环
// wordc, 当 i到c 的时候, j 从0 开始循环 才能取到
// wordexist, 
for i := 1; i <= len(s); i++ {
  for j := 0; j < i; j++ {
    word = s[j:i]
    if dp[j] && isExist(word) {
      dp[i] = dp[i] || dp[j]
    }
  }
}
```

5.最长回文子串

```go
// dp[l][r] = (s[l] == s[r] and (r - l <= 2 or dp[l + 1][r - 1]))
for r := 1; r < len(s); r++ {
  for l := 0; l < r; l++ {
  }
}
```

### 扔鸡蛋

鸡蛋数: k, 楼层: n  
结果: 最坏情况下

- 两个状态 k 和 n
- 两个结果
  - 碎: k - 1, [1, n-1] -> i - 1
  - 不碎: k, [n+1, n] -> n - i // 分到了上面, 那也是当成从 0 层重新开始
- dp[i][j] 表示当前第 i 次操作且使用 j 个鸡蛋可以测得的最高楼层数
  - dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1 // 碎 + 不碎 + 1

### 打家劫舍系列

- 337.打家劫舍 III

    ```go
    // 超时
    return max(robRoot(root), robPass(root))
    robRoot() { root.val + robPass(root.left) + robPass(root.right) }
    robPass() { rob(root.left) + rob(root.right) }
    ```

    ```c++
    int rob(TreeNode* root) {
      int l = 0, r = 0;
      return helper(root, l, r);
    }
    int helper(TreeNode* node, int& l, int& r) {
      if (!node) return 0;
      int ll = 0, lr = 0, rl = 0, rr = 0;
      l = helper(node->left, ll, lr);
      r = helper(node->right, rl, rr);
      return max(node->val + ll + lr + rl + rr, l + r);
    }
    ```

### 跳跃游戏

- 55.跳跃游戏 -> 能否达到

    ```go
    // 1.
    // dp 表示是否能够达到第 i 个节点
    dp[i] = dp[j] && num[j] >= i - j
    // 2.
    // dp 表示第 i 节点最远的坐标
    dp[i] = max(dp[i-1], num[i] + i)
    ```

- 45.跳跃游戏II -> 最少次数

    ```go
    dp[i] = min(dp[i], dp[j] + 1 if (nums[j] > i - j))
    ```

### 子序列系列

- 300.最长上升子序列

    ```go
    // dp[i] = max(dp[j] && ai > aj)  
    for i := 1; i < len(nums); i++ {
      for j := 0; j < i; j++ {
        if nums[i] > nums[j] {

        }
      }
    }
    ```

- 674.最长连续递增序列
- 152.乘积最大子序列

    ```go
    max[i] = max(max[i-1]*nums[i], nums[i], min[i-1]*nums[i])
    min[i] = min(min[i-1]*nums[i], nums[i], max[i-1]*nums[i])
    ```
