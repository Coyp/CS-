# 动态规划

- 实质: 求最优解, 并且该问题可以分为多个子问题, 本质是在穷举
- 特点
  - 子问题会重复计算, 因此需要 dp 去优化过程
  - 自底向上 -> 可以使用 for 循环就可以完成遍历 (自上向下: 通过递归完成)

## 框架

1. 状态 -> 写出状态转移  
2. 选择 -> 遍历选择

## 复杂度

动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。

## 题

### 字符串匹配

1. 通配符匹配 (?一个字符, *零个或者多个)
    - dp[0][0] = true && dp[0][i] = dp[0][i-1] && p[i] == '*'
    - s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
    - p[j] == '*' -> dp[i][j] = dp[i-1][j](ab a\* 多个, 只要\* 前匹配即可) || dp[i][j-1](ab ab\* 零个\*)

2. 正则表达式匹配 (?一个字符, *前面的任意多个) 
    - 与上面的区别在于, x*, x 可以是不相同的, 而上面前面的已经是相同的
    - s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
    - p[j] == '*' -> 若想 p[j] = s[i] 那么必须要\*前面的数字等于 s[i] 才可以
      - p[j-1] == '?' || s[i] == p[j-1] -> dp[i][j] = dp[i-1][j] || dp[i][j-2]
        - 后面已经匹配, 只需要考虑前面是否匹配即可
        - 删: 没有匹配 -> dp[i][j-2] -> abcb abcbb*
        - 删: 匹配一个 -> dp[i][j-1] -> abcb abcb*
        - 插: 多个字符 -> dp[i-1][j] -> abcbb abcb* -> 删除 s 的
      - p[j-1] != '?' && s[i] != p[j-1] -> dp[i][j] = dp[i][j-2] 
        - \*为零 -> abc / abcd\* -> d != c -> 删除 c\*

3. 编辑距离 (将 str2 通过增删替换成 str1)
    - str1[i] == str2[j] -> dp[i][j] = dp[i-1][j-1]
    - !=
      - dp[i-1][j] j 中插入
      - dp[i][j-1] j 中删除
      - dp[i-1][j-1] j 中替换

    ```c++
    // 边界, 若 str1 为空, 那么要将 str2 全部删除
    // 若 str2 为空, 那么要将 str2 全部插入一遍
    for (int i = 1; i <= m; i++)
        dp[i][0] = i;
    for (int j = 1; j <= n; j++)
        dp[0][j] = j;
    ```

4. 最长回文子串

- dp 表示当前 i,j 是回文

    ```go
    // dp[l][r] = (s[l] == s[r] and (r - l <= 2 or dp[l + 1][r - 1]))
    dp := make([][]int, len(s)) // 同一个串, 没有空的含义
    for r := 1; r < len(s); r++ {
      for l := 0; l < r; l++ {
      }
    }
    ```

- dp 表示当前 i,j 的最长长度

    ```go
      if (s[l] == s[r]) {
        dp[l][r] = dp[l+1][r-1] + 2
      } else {
        dp[l][r] = max(dp[l+1][r], dp[l][r-1])
      }
    return dp[0][len(s)-1]
    ```

139.单词拆分

```go
// 字符串的循环
// wordc, 当 i到c 的时候, j 从0 开始循环 才能取到
// wordexist, 
for i := 1; i <= len(s); i++ {
  for j := 0; j < i; j++ {
    word = s[j:i]
    if dp[j] && isExist(word) {
      dp[i] = dp[i] || dp[j]
    }
  }
}
```

### 子序列

- 300.最长上升子序列

    ```go
    // dp[i] = max(dp[j] && ai > aj)  
    for i := 1; i < len(nums); i++ {
      for j := 0; j < i; j++ {
        if nums[i] > nums[j] {

        }
      }
    }
    ```

- 674.最长连续递增序列
- 152.乘积最大子序列

    ```go
    max[i] = max(max[i-1]*nums[i], nums[i], min[i-1]*nums[i])
    min[i] = min(min[i-1]*nums[i], nums[i], max[i-1]*nums[i])
    ```

- 1143.最长公共子序列

    ```go
    for i range 1, n+1 {
      for j range 1, m+1 {
        if (text1[i-1] == text2[j-1]) {
            dp[i][j] = 1 + dp[i-1][j-1];
        } else {
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
      }
    }
    ```

### 扔鸡蛋

状态: 鸡蛋数 k, 楼层数 n, 第 i 层扔鸡蛋
    - 碎: k - 1, [1, n-1] -> i - 1 层
    - 不碎: k, [n+1, n] -> n - i 层
    - res = min(res, max(dp[k-1][i-1], dp[k][N-i]) 

状态: i 次操作, j 个鸡蛋
dp 含义: 最高楼层
    - dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1 // 碎 + 不碎 + 1

### 打家劫舍系列

- 337.打家劫舍 III

    ```go
    // 超时
    return max(robRoot(root), robPass(root))
    robRoot() { root.val + robPass(root.left) + robPass(root.right) }
    robPass() { rob(root.left) + rob(root.right) }
    ```

    ```c++
    int rob(TreeNode* root) {
      int l = 0, r = 0;
      return helper(root, l, r);
    }
    int helper(TreeNode* node, int& l, int& r) {
      if (!node) return 0;
      int ll = 0, lr = 0, rl = 0, rr = 0;
      l = helper(node->left, ll, lr);
      r = helper(node->right, rl, rr);
      return max(node->val + ll + lr + rl + rr, l + r);
    }
    ```

### 跳跃游戏

- 55.跳跃游戏 -> 能否达到

    ```go
    // 1.
    // dp 表示是否能够达到第 i 个节点
    dp[i] = dp[j] && num[j] >= i - j
    // 2.
    // dp 表示第 i 节点最远的坐标
    if i > dp[i-1] break
    dp[i] = max(dp[i-1], num[i] + i)
    ```

- 45.跳跃游戏II -> 最少次数

    ```go
    // dp 表示跳跃的次数, 只要能从 j 位置跳到 i, 那么去更新 dp
    if (i <= nums[j] + j) {
      dp[i] = min(dp[i], dp[j] + 1)
    }
    ```

### 戳气球

- 312.戳气球
      - dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j];
  
### 买卖股票的时机

第 i 天, 第 k 次buy, 0 表示不持有股票  
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // sell  
第 i 天, 第 k 次buy, 1 表示持有股票  
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) // buy  

return dp[n-1][0][0];  

- 121.买卖股票最佳时机  
