# 回溯法

## 总结

- 若不能重复使用, 则每次 start = i + 1
- 若重复使用, 则每次 start = i
- 若含有重复值, 则 nums[i] != nums[i-1]

## 格式

```c++
void helper() {
    if (跳出条件) return;

    for (挑选) {
        // 若不能放入参数中, 由栈复原的, 应该手动调出
        vec.push_back(1);
        helper(vec, count + 1); //
        vec.pop();
    }
}

```

## 组合总和

``` c
1.元素可以重复使用, 但没有重复元素
Q: [2,3,6,7] target = 7
A:
[7],
[2,2,3]

for (i = start; i < candidates.size(); i++) // 加上start就不会再吃回头草
{
    helper(candidates, tmp, target - candidates[i], i);
    // start 不是 +1, 而是继续当前的, 这样既能重复获取某个值, 又可以避免重复答案
}

2.元素不能重复使用, 但有重复元素
Q: [10,1,2,7,6,1,5]

先排序
再加条件
// 1 1 2 5 6 7 10 只准第一个重复的往后选, 后面的不能再选
if (i == start || candidates[i] != candidates[i - 1]) // 对前一个作对比
{
    helper(candidates, tmp, target - candidates[i], i+1);
}
```

## 全排列

```c++
1. 无重复元素

void helper(vector<int>& nums, int start) {
    swap(nums[begin], nums[i]);
    helper(nums, begin+1);
    swap(nums[begin], nums[i]);
}

2. 有重复元素

if (i == begin || nums[begin] != nums[i]) { // 除第一个以外, 相同的不交换
    swap(nums[begin], nums[i]);
    helper(nums, begin+1);
    swap(nums[begin], nums[i]);
}

```

## 字符串类

- 分割字符串使用begin 和 count 的计数

## N 皇后问题

```c
// 使用回溯法
// 核心: 用一维数组的时候, 对角线判断使用特性: 横坐标差的绝对值 = 纵坐标差的绝对值 -> 同一对角线上
```
