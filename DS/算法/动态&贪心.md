# 动态规划

- 特点: 求最优解, 并且该问题可以分为多个子问题
- 目的: 解决子问题重复计算问题

## 框架

1 状态 -> 写出状态转移  
2 选择 -> 遍历选择

## 复杂度
动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。


## 题

### 字符串匹配类

1.通配符匹配 (?一个字符, *零个或者多个)

- s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
- p[j] == '*' -> dp[i][j] = dp[i-1][j](abc a\* 多个, 只要\* 前匹配即可) || dp[i][j-1](abc abc\* 零个\*)

2.正则表达式匹配 (?一个字符, *前面的任意多个)

- s[i] == p[j] || p[j] == '?' -> dp[i][j] = dp[i-1][j-1]
- p[j] == '*' -> 若想 p[j] = s[i] 那么必须要\*前面的数字等于 s[i] 才可以
  - p[j-1] == '?' || s[i] == p[j-1] -> dp[i][j] = dp[i-1][j] || dp[i][j-2]
    - 后面已经匹配, 只需要考虑前面是否匹配即可
    - 1 没有匹配 -> dp[i][j-2] -> abcb abcbb*
    - 2 一个字符 -> dp[i][j-1] -> abcb abcb*
    - 3 多个字符 -> dp[i-1][j] -> abcbb abcb* -> 删除 s 的
  - p[j-1] != '?' && s[i] != p[j-1] -> dp[i][j] = dp[i][j-2] 
    - \*为零 -> abc / abcd\* -> d != c -> 删除 c\*

### 扔鸡蛋

鸡蛋数: k, 楼层: n  
结果: 最坏情况下

- 两个状态 k 和 n
- 两个结果
  - 碎: k - 1, [1, n-1] -> i - 1
  - 不碎: k, [n+1, n] -> n - i // 分到了上面, 那也是当成从 0 层重新开始
- 
- dp[i][j] 表示当前第 i 次操作且使用 j 个鸡蛋可以测得的最高楼层数
  - dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1// 碎 + 不碎 + 1

# 贪心

- 特点: 大范围的问题可以分解到每一个小问题的最优. eg: 股票的一段时间的上涨, 可以分解为每一日的上涨


结构:
struct Bucket { int val; unordered_set<string> keys; };
list<Bucket> buckets; // list 是有序的, value 大的在前面, 小的在后面
unordered_map<string, list<Bucket>::iterator> m;


insert:
1.map 中不存在 key 
  -> 不存在 val == 1 的链表节点 -> 创建新的
  -> 链表最后存在 val == 1 的节点 -> 加入
2.map 中存在 key
  -> 

del:
