# 回溯法


## 格式

```c++
void helper() {
    if (跳出条件) return;

    for (挑选) {
        // 若不能放入参数中, 由栈复原的, 应该手动调出
        vec.push_back(1);
        helper(vec, count + 1); //
        vec.pop();
    }
}

```

## 组合总和

``` c
1.元素可以重复使用, 但没有重复元素
Q: [2,3,6,7]
A:
[7],
[2,2,3]

for (int i = start; i < candidates.size(); i++) // 加上start就不会再吃回头草
{
    helper(candidates, tmp, target - candidates[i], i); 
    // start 不是 +1, 而是继续当前的, 这样既能重复获取某个值, 又可以避免重复答案
}

2.元素不能重复使用, 但有重复元素
Q: [10,1,2,7,6,1,5]
A:
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]

先排序
再加条件
// 1 1 2 5 6 7 10 只准第一个重复的往后选, 后面的不能再选
if (i == start || candidates[i] != candidates[i - 1]) // 对前一个作对比
{
    helper(candidates, tmp, target - candidates[i], i+1); // 注意加一才不会重复使用一个值 
}
```

## 全排列

```c++
1. 无重复元素
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

void helper(vector<int>& nums, int start) {
    swap(nums[begin], nums[i]);
    helper(nums, begin+1);
    swap(nums[begin], nums[i]);
}

2. 有重复元素
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

if (i == begin || nums[begin] != nums[i]) { // 相同的不交换
    swap(nums[begin], nums[i]);
    helper(nums, begin+1);
    swap(nums[begin], nums[i]);
}

```