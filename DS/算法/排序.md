# sort

## quick sort

- 最好 nlogn 最差 n^2 平均 nlogn

```c++
// 第一版, 最后一步中把最后移到中间去
int pivot = nums[end - 1];
int left = begin;
int right = end - 2;
while (true)
{
    while (left < end - 1 && nums[left] <= pivot) { left++; }
    while (right >= 0 && nums[right] >= pivot) { right--; }
    if (left < right) {
        std::swap(nums[left], nums[right]);
    }
    else {
        std::swap(nums[left], nums[end - 1]);
        break;
    }
}

// 此版本减少了把最后换回中间的操作
int pivot = arr[end - 1];
int first = begin;
int last = end;

while (true) {
    while (arr[first] < pivot) first++;
    last--;
    while (pivot < arr[last]) last--;
    if (!(first < last)) break;
    std::swap(arr[first], arr[last]);
    first++;
}
交错, 跳出循环后
last 指向 L 的最后一个值
first 指向 R 的开头
```

##  归并排序
```c
void MergeSort(vector<int> &Array, int front, int end) {
    if (front >= end) return;

    // 1, 2, 3, 4, 5 -> 1 2 3 / 4 5 -> 1 2 / 3 / 4 / 5
    // 分割到最小
    int mid = front + (end - front) / 2;
    MergeSort(Array, front, mid);
    MergeSort(Array, mid + 1, end);

    Merge(Array, front, mid, end);
}
void Merge(vector<int> &Array, int front, int mid, int end)
```

```python
def mergeSort(arr):
    import math
    if(len(arr)<2): // 拆成数量至多为 2 的数组
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))
```