
# 内存相关

/////////  
栈  
//////////  
虚地址空间 -> 内存映射区  
//////////  
堆  
//////////  
.data // 已初始化的全局变量和局部静态变量, 分配空间, 数据保存在目标文件中  
.bss // 未初始化的全区变量和局部静态变量, 默认值为 0, 因此只预留位置(记录数据所需空间大小)不占空间  
///////// 数据段 -> 读/写存储器  
//////////  
.rodata // 只读数据段, const常量 或 字符串常量, 虚表   
.text // 机器代码  
///////// 代码段 -> 只读存储器  

## 堆

### malloc() - 向堆申请的

1. 堆分配算法 - malloc底层 为了管理从os申请的堆空间

ref: <https://www.cnblogs.com/linhaostudy/p/10632349.html>

- 空闲链表法
  - 所有的空闲块的头（或尾）存有prev和next指针，这些连在一起产生一个链表
  - 弊端：释放空间时无法知道used空间的大小
- 位图
  - 分成大量的块，每个块大小相同
  - 块的使用情况用一个数组表示，其中的value为bit值，用两位表示： 11 头 10 body 00 未使用
  - 缺点：粗粒度等
- 对象池

### 堆和OS

- 可以直接用系统函数申请，但是为了高效，程序一次性向系统申请一块位置（堆），然后通过malloc和free管理
- 若大于128k， malloc会调用mmap向os申请空间


## STL

### 使用allactor管理内存

```c++
vector<> v;  // 栈上申请三个指针 用来管理堆上的一片内存
```

### string

- sso模式：小于一定大小是字符串在栈上，但大于一定大小是分配在堆上的

### 代码使用上

1.含有reserve()/capacity()的容器才需要使用swap释放空间，vector\string\deque内存连续的符合，其余无效  
2.C11使用shrink_to_fit()释放

## allactor 设计

1 需要解决的问题

- 向 system heap 要空间
- 考虑多线程
- 考虑内存不足
- 碎片问题

2 operator::new() 等价 malloc()

