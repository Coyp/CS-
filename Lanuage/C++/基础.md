# 字符串 string  

## 字符串转换问题  

字符串到数字

- std::stoi() // int
- std::stof() // float
- std::stod() // double

数字到字符串

- std::to_string()  

## 字符串流处理

数据流读：istringstream >> ： 读时候以" "为分割符  
数据流写：ostringstream  <<

```c
string str = "i an a boy";  
istringstream is(str);  
string s;  
while(is >> s) {  
  cout << s;  
}  
 ```

## size()和length()的区别

没有区别

## 实现

1.直接拷贝 - eager copy

```c
类似vector三指针法
class string 
{
  iterator begin() { return start; }
  char* start;
  char* finish; // int32_t size_; 可以将指针替换
  char* end_of_storage; // int32_t capacity_;
};
```

2.写时复制 copy-on-write 

```c
class string 
{
  struct Rep
  {
    size_t size;
    size_t capacity;
    size_t refcount;
    char* data[1];
  };
  char* start;
};
```

3.短字符串优化 sso  

短的字符串先通过自身的buffer存储，等超过大小再存储到和eager copy相同

```c
class string
{
  char* start_;
  size_t size;
  static const int kLocalSize = 15;
  union
  {
    char buffer[kLocalSize];
    size_t capacity;
  } data;
}
```

## 写自己的String类

```c
// 关键: 
// 1.申请内存是 (length+1) 
// 2.拷贝构造初始没值, 而=重载初始有值
// 3.重载=时, 返回值为引用, 可以做其他复合操作

class MyString
{
public:
  MyString(const char* str);
  MyString(const MyString& other);
  MyString(const MyString&& other);
  ~MyString();

  MyString& operator =(const MyString& other);
  
private:
  char* data_;
};
 
MyString::MyString(const char* str) // str中已经包含了空的情况
{
  if (str == nullptr)
  {
    data_ = new char[1];
    data_[0] = '\0';
  }
  else
  {
    int length = strlen(str); // 到'\0'停止，因此要开length+1的长度
    data_ = new char[length + 1];
    strcpy(data_, str);
  }
}

// 拷贝构造函数啊，就是用来构造用的啊。因此不需要再初始化成员变量
// string a = b; 也是拷贝构造函数
MyString::MyString(const MyString& other) 
{
  int length = strlen(other.data_);
  this->data_ = new char[length + 1];
  strcpy(this->data_, other.data_);
}

//右值引用——移动构造函数
//通过转移范围 指针的寿命被延长
MyString::MyString(MyString&& other)
{
  this->data_ = other.data_;
  other.data_ = nullptr; // 右值必须被修改，否则会被释放
}

// 重载意味着 a = b 既之前已经有值了
MyString& MyString::operator=(const MyString& other) 
{
  if (&other == this) return *this;

  delete[] this->data_;

  int length = strlen(other.data_);
  this->data_ = new char[length + 1];
  strcpy(this->data_, other.data_);

  return *this; // 这样返回可以做复合操作
}
 
MyString::~MyString()
{
  delete[] data_;
}
```


# 关键字  

## 1.sizeof()

// 求类型大小的关键字，**可以省略括号**  
1）数组: int[10] a; -> sizeof(a) 10\*4 = 40  
2）其他为类型: int\* a; -> sizeof(a)  4  
3）若数组作为函数的参数进行传参时，数组会自动退化为指针  
4) 引用: 所引用对象的类型  
int GetSize(int data[]) { sizeof(data); } // 此时求的是指针的大小  

## 2.static

1 用法  
a. C语言  
第一种：函数内修饰变量，生命周期长于该函数；  
第二种：文件级别（函数外），修饰变量或函数，表示只在本文件可见 —— 新标准中推荐使用匿名空间实现  
b. C++语言  
属于整个类, 而不是具体的某个对象  
第三种：修饰class数据成员（静态成员），生命周期长于对象  
第四种：修饰class成员函数（静态成员函数），只能访问static 修饰的静态变量

2 初始化问题  
a.全局静态变量/局部静态变量
编译阶段就已经初始化完成  
b.类内静态变量  
必须在类外部定义：如果在类内初始化，会导致每个对象都包含该静态成员，并且需要在编译阶段就已经初始化完成  

## 3.const

1）const和类型交换位置等价

```c
const int n = 0
int const n = 0 
```

2）const指针类型

```c
const char* p // const 指针所指的值
char const* p // 两者等价

char* const p // const 指针
```

## 4.volatile

- hint 编译器, 不做编译优化, 每次从内存中取此值, 而不是直接使用已经在寄存器中的值


# 其他

## 1.语义

1.值语义与对象语义（引用语义）  
1）值语义  
定义：拷贝之后与原对象没有关系，比如 int a = b， 赋值后a就是单独的值 string,vector,map  
特点：容易控制生命周期  
2）对象语义  
定义：禁止拷贝或者拷贝后通过多个引用或者指针对同一个底层地址进行操作  
特点：不容易控制生命周期，可以通过智能指针实现  

## 2.函数返回值

1）返回后构造出新的b来，a是被析构掉的

```c
string getString()
{
  string a = "123";
  return a;
}

string b = getString() // ok,b重新被构造，而a被析构

string& getString()
{
  string a = "123";
  return a;
}

string b = getString(); // 此时返回a的引用，但是a被析构，因此b会是空的
```
