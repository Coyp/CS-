# 基本概念

1. 变量
    - 全局变量
    - 静态全局变量(只在本文件可见)
    - 静态局部变量 -> 以上都在静态存储区
    - 局部变量 -> 内存的栈区

2. 常量
    - static const 限定了只能在此文件使用

# 字符串 string

## 字符串转换问题  

```c++
// 1. 字符串到数字
std::stoi() // int
std::stof() // float
std::stod() // double

// 2. 数字到字符串
std::to_string()  

// 3. char 转为 string
string str(1, 'a');
```

## 字符串流处理

数据流读：istringstream >> ： 读时只能以" "为分割符，会在第一次字符停止
数据流写：ostringstream <<

```c++
// 例1
string str = "i an a boy";  
istringstream is(str);  
string s;  
while(is >> s) {  
  cout << s;  
}  

// 例2
int num1 = 0, num2 = 0;
char tmp;
while (bool(in1 >> num1) + bool(in2 >> num2)) {
    if (num1 > num2) return 1;
    else if (num1 < num2) return -1;

    num1 = 0; // 防止某一个字符串先走完，导致后续没有初始化
    num2 = 0;
    in1 >> tmp; // 专用于接受分隔符
    in2 >> tmp;
}
 ```





## size()和length()的区别

没有区别

## 实现

1.直接拷贝 - eager copy

```c
类似vector三指针法
class string 
{
  iterator begin() { return start; }
  char* start;
  char* finish; // int32_t size_; 可以将指针替换
  char* end_of_storage; // int32_t capacity_;
};
```

2.写时复制 copy-on-write

```c
class string
{
  struct Rep
  {
    size_t size;
    size_t capacity;
    size_t refcount;
    char* data[1];
  };
  char* start;
};
```

3.短字符串优化 sso  

短的字符串先通过自身的buffer存储，等超过大小再存储到和eager copy相同

```c
class string
{
  char* start_;
  size_t size;
  static const int kLocalSize = 15;
  union
  {
    char buffer[kLocalSize];
    size_t capacity;
  } data;
}
```

## 写自己的String类

```c
// 关键: 
// 1.申请内存是 (length+1) 
// 2.拷贝构造初始没值, 而=重载初始有值
// 3.重载=时, 返回值为引用, 可以做其他复合操作

class MyString
{
public:
  MyString(const char* str);
  MyString(const MyString& other);
  MyString(const MyString&& other);
  ~MyString();

  MyString& operator =(const MyString& other);
  
private:
  char* data_;
};
 
MyString::MyString(const char* str) // str中已经包含了空的情况
{
  if (str == nullptr)
  {
    data_ = new char[1];
    data_[0] = '\0';
  }
  else
  {
    int length = strlen(str); // 到'\0'停止，因此要开length+1的长度
    data_ = new char[length + 1];
    strcpy(data_, str);
  }
}

// 拷贝构造函数啊，就是用来构造用的啊。因此不需要再初始化成员变量
// string a = b; 也是拷贝构造函数
MyString::MyString(const MyString& other) 
{
  int length = strlen(other.data_);
  this->data_ = new char[length + 1];
  strcpy(this->data_, other.data_);
}

//右值引用——移动构造函数
//通过转移范围 指针的寿命被延长
MyString::MyString(MyString&& other)
{
  this->data_ = other.data_;
  other.data_ = nullptr; // 右值必须被修改，否则会被释放
}

// 重载意味着 a = b 既之前已经有值了
MyString& MyString::operator=(const MyString& other) // 返回值必须是类的&, 因为可以连续赋值
{
  if (&other == this) return *this; // 若相同, 那么接下来删除内存会导致原来的也被删掉

  delete[] this->data_;

  int length = strlen(other.data_);
  this->data_ = new char[length + 1]; // 有可能会申请失败
  strcpy(this->data_, other.data_);

  return *this; // 这样返回可以做复合操作
}

// new 可能会失败, 但是已经 delete, 因此借助类的申请去new
MyString& MyString::operator=(const MyString& other) {
  if (&other != this) {
    MyString tmp(other); //  借助了类的拷贝构造函数去 new, 失败也不会导致原来的被释放

  }
}

MyString::~MyString()
{
  delete[] data_;
}
```

# 关键字

## 1.sizeof()

// 求类型大小的关键字，**可以省略括号**  
1）数组: int[10] a; -> sizeof(a) 10\*4 = 40  
2）其他为类型: int\* a; -> sizeof(a)  4  
3）若数组作为函数的参数进行传参时，数组会自动退化为指针  
4) 引用: 所引用对象的类型  

```c
int[10] a = {1, ,2, 3}; // sizeof(a) -> 3*4;
int*b = a // sizeof(b) -> 4
GetSize(a); // int GetSize(int a[]) { sizeof(a); -> 4} 退化为指针  
```

## 2.static

1. 用法  
  a. C语言  
  第一种：函数内修饰变量，生命周期长于该函数；  
  第二种：文件级别（函数外），修饰变量或函数，表示只在本文件可见 —— 新标准中推荐使用匿名空间实现  
  b. C++语言  
  属于整个类, 而不是具体的某个对象  
  第三种：修饰class数据成员（静态成员），生命周期长于对象  
  第四种：修饰class成员函数（静态成员函数），只能访问static 修饰的静态变量

2. 初始化问题  
  a.全局静态变量/局部静态变量  
  编译阶段就已经初始化完成  
  b.类内静态变量  
  必须在类外部定义：如果在类内初始化，会导致每个对象都包含该静态成员，并且需要在编译阶段就已经初始化完成  

3 static 限定了文件内 private = 匿名空间 namespace {}

## 3.const

1）const和类型交换位置等价

```c
const int n = 0
int const n = 0
```

2）const指针类型

```c
const char* p // const 指针所指的值
char const* p // 两者等价

char* const p // const 指针
```

## 4.volatile

- hint 编译器, 不做编译优化, 每次从内存中取此值, 而不是直接使用已经在寄存器中的值

## 5.转换

### static_cast

- 转换数值数据类型
- 可以在类层次结构中移动指针

### dynamic_cast

- 多态类型转换
- 只适用于指针或引用
- 对不明确的指针转换失败会返回 nullptr

### const_cast

- 用于删除 const/ volatile/ __unaligned 特性

### reinterpret_cast

- 比特的重新解释
- 任何指针之间的相互转换

# 其他

## 1.语义

1. 值语义  
    定义：拷贝之后与原对象没有关系，比如 int a = b， 赋值后a就是单独的值 string,vector,map  
    特点：容易控制生命周期  
2. 对象语义  
    本质: 把底层的指针包了起来
    定义：禁止拷贝或者拷贝后通过多个引用或者指针对同一个底层地址进行操作  
    特点：不容易控制生命周期，可以通过智能指针实现  

## 2.函数返回值

1）返回后构造出新的b来，a是被析构掉的

```c
string getString()
{
  string a = "123";
  return a;
}

string b = getString() // ok,b重新被构造，而a被析构

string& getString()
{
  string a = "123";
  return a;
}

string b = getString(); // 此时返回a的引用，但是a被析构，因此b会是空的
```
