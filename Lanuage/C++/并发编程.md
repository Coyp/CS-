# 并发编程

## 基础

1. 两种基本模型
    - message passing -> 基本使用消息传递来保证正确性
    - shared memory

## C11 支持的同步原语

### mutex 互斥器

#### 不同的锁

- mutex // 普通
- recursive_mutex // 递归, 可重入锁
  - 不推荐使用
  - 支持锁套锁, 不会死锁, 不可重入锁会死锁

- time_mutex // 定时
- recursive_timed_mutex // 定时递归

#### Lock 类包装

```c++
lock_gruad<std::mutex>  
unique_lock<std::mutex> // 中间还可以进行临时解锁  
```

### condition_variable 条件变量

```c
std::unique_lock<std::mutex> lk(m); // 条件变量中只能使用unique_lock<>
cv.wait(lk, pre()) // == while(pre()) {cv.wait();}
// 1.先获得lk锁, 然后 wait 阻塞, 此时先释放锁
// 2.直到被唤醒 1.检测 pre 条件通过 2.重新获取锁, 解除阻塞
```

### future

### 函数

```c
std::call_one() // 多个线程需要同时调用某个函数, 可以保证只调用一次
```

## 总结

1. 不要使用读写锁
2. 不使用信号量
3. sleep() 可以出现在测试代码中, 延长临界区, 加速复现死锁情况

## 应用

### CountDownLatch

1. 作用: 主线程等待其他子线程执行完成后, 再执行主线程 或者 子线程等待主线程
2. 代码: 条件变量的应用

    ```c++
    class CountDownLatch {
        void wait(); { unique_lock<mutex> l(mtx_); con_.wait(l, func())}
        void countDown();
    }
    ```
