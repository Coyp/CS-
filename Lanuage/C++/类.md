# Class相关

## 构造函数

- 线程安全的构造函数: 不能在构造函数中暴露 this 指针
  - 若一开始需要注册回调, 那么需要构造好后单独再执行

## 析构函数

- 不能使用成员锁去保证析构的线程安全: 若线程 A 占有锁并开始析构, 而线程 B 等待锁并阻塞, 此时析构会把锁删除, 那么 B 的行为会有问题

## 空类的大小

（sizeof） = 1，声明类型的实例时，必须在内存中占有一定的内存  

## 友元函数

特点

- 不是类成员
- 可以让外部函数访问内部 private 和 protected 的数据

## 2.运算符重载  

1）参数个数  

- 成员函数:函数的参数个数比原来参与运算的运算数少一个: 重载一元运算符没有参数、重载二元运算符只有一个参数；比如，a + b 的参数为1个，a = b 的参数为1个 -> 因为含有 this 指针
- 友元函数:参数个数与原运算数个数相同，因为没有this指针  

2）<<和>>只能用友元函数来重载

- 为了保证使用cin或者cout  

```c
friend istream& operator >>(istream& in, MyClass& c);
istream& operator >>(istream& in, MyClass& c){
  in >> c
  return in;
}
```

## 3.构造函数与析构函数  

1）  
构造函数是否能为虚函数：不能，构造函数的意义就是把这个类型给创建起来，地基都没有了谈什么  
析构函数是否能为虚函数：如果基类有派生类，则必须，否则会导致派生类的析构函数不能执行  
2）  
派生类构造函数调用重写函数：可以表现多态性 （说明构造函数执行前虚指针与虚表已经完成）  
派生类析构函数调用重写函数：可以表现多态性  
3）  
若构造函数与析构函数为私有函数  
构造函数和析构函数的调用是外部调用，因此设置为私有意味着不能完成实例化，但是可以通过static单例的方式创建在堆上  

## 4.类权限的控制

1) protected 可以用来保护基类不被创建, 而子类可以被创建

```c++
class A { 
protected: 
    A(){}
};
 
class B : public A
{
    public: B(){}
};
 
int main(int argc, char** argv){
    A a; // error
    B b; // ok
}
```

2) private 了构造函数和析构函数后, 只能通过内部函数调用, 并且可以借用 static 将其初始化到堆上, 这样就可以调用到内部函数. -> 单例的应用, 全局仅有一个

```c++
class A
{
private:
    A() {}
    ~A(){}
public:
    static A& Instance()
    {
        static A a;
        return a;
    }
};
 
int main() {
    A& ra = A::Instance();
}
```

3) 基类中的私有函数可以被派生类继承 -> 访问权限和const一样只是标识，而不影响强行功能  
```c
class Base {
 private:
     virtual void fun() { std::cout << "Base Fun" << std::endl; }
 public:
     virtual void cun() { std::cout << "Base Cun" << std::endl; }
     friend int main();
 };

 class Derived : public Base {
 public:
     void fun() { std::cout << "Derived Fun" << std::endl; }
     void cun() { std::cout << "Derived Cun" << std::endl; }
 };

 int main()
 {
     Base *ptr = new Derived;
     Derived *ptest = new Derived;
     ptr->cun(); // 调用派生类
     ptr->fun(); // 调用派生类
     // 原因：动态束定是运行期间才确定，访问权限是编译时确定的
     return 0;
 }
``` 

## 5.类内成员变量初始化  

```c
class Test
{
public:
  Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。
  ~Test(){}

  int y;      //普通变量成员
  int& r;     //引用成员变量,C11之前必须通过参数初始化列表进行初始化
  const int d;    //常量成员变量，C11之前必须通过参数初始化列表进行初始化
  static int c;   //静态成员变量，不属于类的实例，必须在类外部定义实现
  static const int x = 2.1;   //静态常量整型成员变量
  static const int xx;        //静态常量整型成员变量声明
};
  
const int Test::xx = 4; //静态常量整型成员变量定义
int Test::c = 2;
```

## 6.类实例化的过程

1）分配空间  
2）初始化 -> 初始化列表, 因此参数产生在构造函数之前, 包括虚指针  
3) 赋值 -> 通过构造函数  
<https://blog.csdn.net/gukesdo/article/details/7514080>

## 7.虚函数与虚表  

1 机制  

```c
class A {
  virtual void fa();
  virtual void ga();
};
class B {
  virtual void fb();
  virtual void gb();
};
class C : public A, public B{
  void fa();
  void fb();
  virtual void gc();
}
C继承了两个类，因此会有两个虚表
1) C::fa() A::ga() C::gc() // C中其他的虚拟成员被放到第一个继承类中
2) C::fb() B::gb()
```

2）一个类产生的所有实例共用同一个虚表，则虚指针都相同，虚表在全局变量区  
3）虚指针初始化与参数初始化一起执行，完成后再执行构造函数{ }里面的内容  
4）若子类没有虚函数，但是基类有，那么子类也会拥有虚表和虚指针  
5）**纯虚函数**会使用地址0来占位，因此子类中必须重写，否则地址无效而无法继承  

2 虚表与虚指针在内存中的位置
https://www.cnblogs.com/wangxiaobao/p/5850949.html 内存模型  
1）虽然基类中私有的不能使用，但是内存结构中仍然会继承，也就解释了基类中私有的虚函数仍然能够被重写  
2）只有虚函数（包括继承的而没有重写的）地址才会记入虚表  
3）虚指针和类内其他变量相同的位置，栈或者堆  
4）虚表放在常量区（VS中） 
