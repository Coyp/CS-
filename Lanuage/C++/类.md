# Class相关

## 构造函数

1.线程安全

- 不能在构造函数中暴露 this 指针
  - 若一开始需要注册回调, 那么需要构造好后单独再执行

2.虚函数相关
 
- 不能为虚函数, 构造函数的意义就是把这个类型给创建起来，地基都没有了谈什么  
- 构造函数执行前虚指针与虚表已经完成, 因此构造函数中可以调用重写函数

3.单例

- 构造函数和析构函数由外部调用，设置为private则不能实例化，但可以通过static单例的方式创建在堆上  

## 析构函数

1.线程安全

- 不能使用成员锁去保证析构的线程安全
  - 若线程 A 占有锁并开始析构, 而线程 B 等待锁并阻塞, 此时析构会把锁删除, 那么 B 的行为会有问题

2.虚函数相关

- 如果基类有派生类，则必须有，否则会导致派生类的析构函数不能执行
- 派生类析构函数调用重写函数：可以表现多态性  

## 空类的大小

（sizeof） = 1，声明类型的实例时，必须在内存中占有一定的内存  

## 友元函数

特点

- 不是类成员
- 可以让外部函数访问内部 private 和 protected 的数据

## 运算符重载  

1）参数个数  

- 成员函数:函数的参数个数比原来参与运算的运算数少一个: 重载一元运算符没有参数、重载二元运算符只有一个参数；比如，a + b 的参数为1个，a = b 的参数为1个 -> 因为含有 this 指针
- 友元函数:参数个数与原运算数个数相同，因为没有this指针  

2）<<和>>只能用友元函数来重载

- 为了保证使用cin或者cout  

```c
friend istream& operator >>(istream& in, MyClass& c);
istream& operator >>(istream& in, MyClass& c){
  in >> c
  return in;
}
```

## 类内成员变量初始化  

### 使用初始化列表

- 初始化顺序与初始化列表的顺序无关, 而与变量的定义顺序有关

```c
class Test
{
public:
  Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。
  ~Test(){}

  int y;      //普通变量成员
  int& r;     //引用成员变量,C11之前必须通过参数初始化列表进行初始化
  const int d;    //常量成员变量，C11之前必须通过参数初始化列表进行初始化
  static int c;   //静态成员变量，不属于类的实例，必须在类外部定义实现
  static const int x = 2.1;   //静态常量整型成员变量
  static const int xx;        //静态常量整型成员变量声明
};
  
const int Test::xx = 4; //静态常量整型成员变量定义
int Test::c = 2;
```

## 类实例化的过程

1）分配空间  
2）初始化 -> 初始化列表, 因此参数产生在构造函数之前, 包括虚指针  
3) 赋值 -> 通过构造函数  
<https://blog.csdn.net/gukesdo/article/details/7514080>

## 虚函数与虚表  

1 机制  

```c
class A {
  virtual void fa();
  virtual void ga();
};
class B {
  virtual void fb();
  virtual void gb();
};
class C : public A, public B{
  void fa();
  void fb();
  virtual void gc();
}
C继承了两个类，因此会有两个虚表
1) C::fa() A::ga() C::gc() // C中其他的虚拟成员被放到第一个继承类中
2) C::fb() B::gb()
```

2）一个类产生的所有实例共用同一个虚表，则虚指针都相同，虚表在全局变量区  
3）虚指针初始化与参数初始化一起执行，完成后再执行构造函数{ }里面的内容  
4）若子类没有虚函数，但是基类有，那么子类也会拥有虚表和虚指针  
5）**纯虚函数**会使用地址0来在虚表中占位，因此子类中必须重写，否则地址无效而无法继承  

2 虚表与虚指针在内存中的位置

<https://www.cnblogs.com/wangxiaobao/p/5850949.html> 内存模型  

1）虽然基类中私有的不能使用，但是内存结构中仍然会继承，也就解释了基类中私有的虚函数仍然能够被重写  
2）只有虚函数（包括继承的而没有重写的）地址才会记入虚表  
3）虚指针和类内其他变量相同的位置
4）虚表在程序只读数据段(.rodata)

## 接口

1. 接口方法使用纯虚函数修饰
2. 接口类无法创建对象, 因此不应该编写构造函数和析构函数
3. 可以声明静态常量作为接口的返回值状态


## 关键字

### protected  

1 可以用来保护基类不被创建, 而子类可以被创建

```c++
class A { 
protected: 
    A(){}
};
 
class B : public A
{
    public: B(){}
};
 
int main(int argc, char** argv){
    A a; // error
    B b; // ok
}
```

2 子类可以访问  

### private

1 可以创建单例

```c++
class A
{
private:
    A() {}
    ~A(){}
public:
    static A& Instance()
    {
        static A a;
        return a;
    }
};
 
int main() {
    A& ra = A::Instance();
}
```

2 只有自己可以访问  

3 基类中的private可以被派生类继承 -> 访问权限和const一样只是标识，而不影响强行功能

### explicit

1 修饰构造函数, 不能发生隐式类型转换

