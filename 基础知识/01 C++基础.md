# STL
## 迭代器
### 1.输入和输出
```c
// 输入和输出
std::istream_iterator<int> is(cin); //绑定标准输入作为开始
std::istream_iterator<int> eof; //定义输入结束位置
std::copy(is, eof, back_inserter(to_vector));
std::copy(to_vector.begin(), to_vector.end(), std::ostream_iterator<int>(std::cout, " ")); // 利用ostream的迭代器输出到cout中
```
## 容器
1.序列式容器 —— 内存连续分配   
vector —— 数组 （增导致resize、删导致后续会往前移、插会导致后续往后移都是导致迭代器失效）   
deque —— 双端队列（数组+链表结合，同vector导致迭代器失效）   
string  
注：仍然可以使用erase，会返回新迭代器的下一个新地址  
2.关联容器
map —— 红黑树  
set —— 红黑树  
unordered_map —— hash  
3.链表
list —— 双向链表  
4.STL拓展
stack —— list  
queue —— list  
priority_queue —— vector 
### string  
#### 1.字符串转换问题  
字符串到数字 std::stoi()   
数字到字符串 std::to_string()  
#### 2.字符串流处理  
数据流读：istringstream >> ： 读时候以" "为分割符  
数据流写：ostringstream  <<   
```c
string str = "i an a boy";  
istringstream is(str);  
string s;  
while(is >> s) {  
  cout << s;  
}  
 ```
#### 3.size()和length()的区别
没有区别
#### 4.实现
1.直接拷贝 - eager copy 
```c
类似vector三指针法
class string 
{
  iterator begin() { return start; }
  char* start;
  char* finish; // int32_t size_; 可以将指针替换
  char* end_of_storage; // int32_t capacity_;
};
```
2.写时复制 copy-on-write  
```c
class string 
{
  struct Rep
  {
    size_t size;
    size_t capacity;
    size_t refcount;
    char* data[1];
  };
  char* start;
};
```
3.短字符串优化 sso  
短的字符串先通过自身的buffer存储，等超过大小再存储到和eager copy相同
```c
class string
{
  char* start_;
  size_t size;
  static const int kLocalSize = 15;
  union
  {
    char buffer[kLocalSize];
    size_t capacity;
  } data;
}
```
#### 5.写自己的String类
```c
class MyString 
{
public:
  MyString(const char* str);
  MyString(const MyString& other);
  MyString& operator =(const MyString& other);
  ~MyString();
private:
  char* data_;
};
 
MyString::MyString(const char* str) // str中已经包含了空的情况
{
  if (str == nullptr)
  {
    data_ = new char[1];
    data_[0] = '\0';
  }
  else
  {
    int length = strlen(str); // 到'\0'停止，因此要开length+1的长度
    data_ = new char[length + 1];
    strcpy(data_, str);
  }
}

// 拷贝构造函数啊，就是用来构造用的啊。因此不需要再初始化成员变量
// string a = b; 也是拷贝构造函数
MyString::MyString(const MyString& other) 
{
  int length = strlen(other.data_);
  this->data_ = new char[length + 1];
  strcpy(this->data_, other.data_);
}

//右值引用——移动构造函数
MyString::MyString(MyString&& other)
{
  this->data_ = other.data_;
  other.data_ = nullptr; // 右值必须被修改，否则会被释放
}

MyString& MyString::operator=(const MyString& other) // = 意味着之前已经有值了
{
  if (&other == this) return *this;

  delete[] this->data_;

  int length = strlen(other.data_);
  this->data_ = new char[length + 1];
  strcpy(this->data_, other.data_);

  return *this; // 这样返回可以做复合操作
}
 
MyString::~MyString()
{
  delete[] data_;
}
```
### vector
1.释放内存 shrink_to_fit    
2.几个成员函数辨析  
size() 返回当前n的大小   
resize(int n) 若 n < size: 多出来的尾部元素将被析构 size < n < capacity: 调用构造函数填充 n >capacity: 扩容并填充  
capacity() 返回当前capacity大小   
reserve(int n) 直接将capacity扩充到n，避免自动多次分配，推荐一开始就做  
### set

### map
1.插入效率问题  
新建：insert，因为[]会先构造一个空的类，再赋值，这个过程中就多了一步    
更新：operator[]  

## 应用
### 1.删除元素的方法
1.内存连续分配
```c
1) 借助std::remove()函数
c.erase(std::remove(c.begin(), c.end(), value), c.end()) // remove()将==value的值都放到后面，但是不删除
c.erase(std::remove_if(c.begin(), c.end(), function), c.end()) // remove_if() value替换成function
2) 使用迭代器
for (iter = vector.begin(); iter != vector.end(); /**/)
{
  if (ok) iter = vector.erase(iter); // 内存连续分配的erase后，后面的元素会往前移动，因此迭代器会改变，这里需要重新设置，不然会漏或者出问题
  else iter++;
}
```
2.list
```c
1）
c.remove(value)
c.remove_if(function) //
2）使用迭代器
同map，删除后迭代器会保持原来的值
```
3.关联容器 
```c
1）
map.erase(value);
2）使用迭代器
for (iter = map.begin(); iter != map.end(); /**/)
{
  if (ok) map.erase(iter++); // 删除后迭代器会保持原来的值，因此需要加一下
  else iter++;
}

全部删除时，可以用while
map::iterator iter = map.begin();
while (iter != map.end())
{
  map.erase(iter++);
}
```

# Class相关  
## 1.空类的大小  
（sizeof） = 1，声明类型的实例时，必须在内存中占有一定的内存  
## 2.运算符重载  
1）参数个数  
当重载为类的成员函数时，函数的参数个数比原来参与运算的运算数少一个：重载一元运算符没有参数、重载二元运算符只有一个参数；比如，a + b 的参数为1个，a = b 的参数为1个  
当重载为类的友元函数时，参数个数与原运算数个数相同，因为没有this指针  
2）<<和>>只能用友元函数来重载  
为了保证使用cin或者cout  
## 3.构造函数与析构函数  
1）  
构造函数是否能为虚函数：不能，构造函数的意义就是把这个类型给创建起来，地基都没有了谈什么  
析构函数是否能为虚函数：如果基类有派生类，则必须，否则会导致派生类的析构函数不能执行  
2）  
派生类构造函数调用重写函数：可以表现多态性 （说明构造函数执行前虚指针与虚表已经完成）  
派生类析构函数调用重写函数：可以表现多态性  
3）  
若构造函数与析构函数为私有函数  
构造函数和析构函数的调用是外部调用，因此设置为私有意味着不能完成实例化，但是可以通过static单例的方式创建在堆上  
## 4.类内成员变量初始化  
```c
class Test
{
public:
  Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。
  ~Test(){}

  int y;      //普通变量成员
  int& r;     //引用成员变量,C11之前必须通过参数初始化列表进行初始化
  const int d;    //常量成员变量，C11之前必须通过参数初始化列表进行初始化
  static int c;   //静态成员变量，不属于类的实例，必须在类外部定义实现
  static const int x = 2.1;   //静态常量整型成员变量
  static const int xx;        //静态常量整型成员变量声明
};
  
const int Test::xx = 4; //静态常量整型成员变量定义
int Test::c = 2;
```
## 5.类实例化的过程  
1）分配空间  
2）初始化  
https://blog.csdn.net/gukesdo/article/details/7514080  
## 6.虚函数与虚表  
1）同一个类产生的所有实例的虚指针都指向同一个虚表地址，因此虚表在全局变量区  
2）虚指针初始化与参数初始化一起执行，完成后再执行构造函数{ }里面的内容  

# 标准库函数
**算法相关**
## 1.std::sort()
https://blog.csdn.net/ihadl/article/details/7400929  
1）仿函数 
```c
less<int>()  
```
2）自定义仿函数  
```c
struct cmp {
  bool operator()(const Interval& a, const Interval& b) //重载了() {
    return a.start < b.start; // 一定要用大于或者小于号
  }
};

```
3）全局函数 
```c
bool less_second(const myclass& m1, const myclass& m2) {
  return m1.second < m2.second; 
}
```
4）类内重载符号  
```c
class myclass {
  bool operator < (const myclass& m)const {
    return first < m.first;
  }
};
```
**搜索**
## 1.find() / find_if()
find —— 值  
find_if —— 函数
**遍历相关**
## 1.for_each() —— 遍历函数
```c
std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });
```
## 2.copy —— 拷贝
```c
std::copy(from_vector.begin(), from_vector.end(), std::back_inserter(to_vector)); // 复制到另一个容器

// 输入和输出
std::istream_iterator<int> is(cin); //绑定标准输入作为开始
std::istream_iterator<int> eof; //定义输入结束位置
std::copy(is, eof, back_inserter(to_vector));
std::copy(to_vector.begin(), to_vector.end(), std::ostream_iterator<int>(std::cout, " ")); // 利用ostream的迭代器输出到cout中
```
## 3.transform —— 拷贝 + 遍历函数
将容器内的元素通过函数后，存入新的容器中  
```c++
std::string s("hello"); // 第一个完全可以被for_each取代
std::transform(s.begin(), s.end(), s.begin(), // 若想使用begin(), 长度必须大于等于要copy过来的元素大小
	   [](unsigned char c) -> unsigned char { return std::toupper(c); }); // int toupper(int c) 转换大写 

std::vector<std::size_t> ordinals;
std::transform(s.begin(), s.end(), std::back_inserter(ordinals), // 否则新的必须使用插入，或者通过resize()扩充大小
	   [](unsigned char c) -> std::size_t { return c; });

std::cout << s // HELLO
for (auto ord : ordinals) {
  std::cout << ' ' << ord; // 72 69 76 76 79
}
```
**插入**
## 1.back_inserter() / inserter()


# 内存相关
## 1.malloc()  
1）内存是块状链表形式：头部包括自身指针、下一块指针、内存大小  
2）申请：从空闲的链表中拿到，若大小合适直接从空闲链表中取下；若大小太大，则根据申请大小修改内存头部一部分留在空闲链表，一部分拿下来  
3）释放：扫描空闲链表寻找合适的位置，若存在相邻的空闲块，则进行合并，减少碎片  
## 2.STL释放内存
1.含有reserve()/capacity()的容器才需要使用swap释放空间，vector\string\deque内存连续的符合，其余无效  
2.C11使用shrink_to_fit()释放  

# 关键字  
## 1.sizeof() 
// 求类型大小的关键字，**可以省略括号**  
1）数组：int[10] a; -> sizeof(a) 10\*4 = 40  
2）其他为类型的字节大小 int \*a; -> sizeof(a)  4  
3）若数组作为函数的参数进行传参时，数组会自动退化为指针  
int GetSize(int data[]) { sizeof(data); } // 此时求的是指针的大小  
## 2.static
1) 用法  
a. C语言  
第一种：函数内修饰变量，生命周期长于该函数；  
第二种：文件级别（函数外），修饰变量或函数，表示只在本文件可见 —— 新标准中推荐使用匿名空间实现  
b. C++语言  
第三种：修饰class数据成员（静态成员），生命周期长于对象  
第四种：修饰class成员函数（静态成员函数），只能访问class variable
2）初始化问题  
a.全局静态变量/局部静态变量
编译阶段就已经初始化完成
b.类内静态变量  
必须在类外部定义：如果在类内初始化，会导致每个对象都包含该静态成员，并且需要在编译阶段就已经初始化完成  
## 3.const
1）const和类型交换位置等价
```c
const int n = 0
int const n = 0 
```
2）const指针类型
```c
const char* p // const 指针所指的值
char const* p // 两者等价

char* const p // const 指针
```
# C++11 
## 1.关键字
1.NULL与nullptr  
NULL在编译时会被替换为0，因此会导致函数默认值的多义；  
nullptr仅表示空指针  
## 2.右值引用
1.值语义与对象语义（引用语义）  
1）值语义  
定义：拷贝之后与原对象没有关系，比如 int a = b， 赋值后a就是单独的值 string,vector,map  
特点：容易控制生命周期  
2）对象语义  
定义：禁止拷贝或者拷贝后通过多个引用或者指针对同一个底层地址进行操作  
特点：不容易控制生命周期，可以通过智能指针实现  
2.右值与左值  —— 根本区别在于是否允许取地址&运算符获得对应的内存地址  
1）左值  
左值是对应（refer to）内存中有确定存储地址的对象的表达式的值  
2）右值  
右值是所有不是左值的表达式的值，因而右值可以是字面量、临时对象等表达式。 **字面量和临时对象也是会申请空间**  
3.右值引用 —— 移动语义 + 完美转发  
1）移动语义（与拷贝语义相对）  
背景：用临时对象或者字面量赋值或者返回值后会自动释放，造成已经申请过的再释放一遍，可以通过移动语义将此时的资源再利用起来   
实现逻辑：把临时对象的指针拿出来再保存给周期长的对象，给将要销毁的对象赋值为nullptr，该销毁的还是会被销毁  
a.临时对象通过一个接受右值的函数传递给另一个函数后，就会变成左值  
b.move() 将左引用转换为右引用
```c
template <class T> swap(T& a, T& b) 
{ 
  T tmp(std::move(a)); // move a to tmp 
  a = std::move(b);    // move b to a 
  b = std::move(tmp);  // move tmp to b 
} // 避免了三次拷贝
```
2）完美转发  
## 3.智能指针
用栈上对象（智能指针对象）来管理堆上对象的生存期  
## 4.初始化列表
std::initializer_list<> 初始化列表类型  
1.可以防止类型隐式转换  
```c++
std::vector<string> v1 = {"hello", "world", "welcome"};   
std::vector<int> v2 = {0, 3, 8, 1, 4};  
int a[] = {4,5,6};
```
2.给类提供了{}初始化的方法，写出带初始化list的构造函数  
```c++
// before c11
int a[3] = {1, 2, 3};
std::vector<int> b = {1, 2, 3};

Foo foo(1, 2); //

// before c11
int a[3] = {1, 2, 3};
std::vector<int> b = {1, 2, 3};

Foo foo(1, 2); // 不能实现 

// after c11
class Foo {
  Foo(std::initializer_list<int> l) {
   for (int i : l) {}
  }
};
```
## 5.lambda函数
[captrue] (params) -> ret {body}; // 若根据body返回值能够确定类型，那么ret可以省略  
1.无参数传入 —— 可以捕获外部值进行函数式的判断  
```c++
int main()
{
  int a;
  [=]() { return 1 + a; } // 值传入，前提是变量可以被拷贝，在lambda函数创建时拷贝，而不是调用的时候拷贝  
  [&]() { return 1 + a; } // 引用传入
  [this]() { } // 当前域对象
}
```
2.参数传递 —— 可以在后续当做函数使用，用function来保存
```c++
std::function<int (int a)> f = [](int a) -> int { return a + 1; }; // std::function<int (int x)>
std::cout << f(1) << std::endl;
```
## 6.尾返回类型
```c++
template<typename T, typename U>
auto Add(T t, U u) -> decltype(t + u) // 此处若不使用尾返回类型，而是写到auto的位置，则会报错  
{
  return t + u;
}
```
## 7.function / bind
```c++
int x = 1;

std::function<void (int y)> func;
func = std::bind(&MyTest::TestFunc, this, x, std::placeholders::_1); // bind解决了function一次不能获得全部参数的问题，可以提前给函数绑定一些已知参数

std::cout << func(1) << std::endl;
```
## 8.auto/decltype
1.auto 自动推导表达式类型  
```c++
auto c = 1;
```
2.decltype 当不知道当前变量是什么类型时，可以作为推导，并且不会计算表达式  
```c++
typedef decltype(v.begin()) vectype;

int i = 1;
decltype(i) a; // 推导a的类型为int
```
## 9.constexpr
1.与const区别  
const：readonly，不能进行修改    
constexpr：声明可以在编译时求得函数或变量的值，使之在编译的时候就变成常量，程序运行的时候可以直接使用，而不再需要计算，因此可以搞一个函数；当声明constexpr后自动变为const，反之不行    
## 10.强类型枚举
不能隐式转换为整数，不同类型之间不能作比较   
```c++
enum class xxx
{
}

enum class Enum2 : unsigned int {Val1, Val2}; // 必须显示指定类型，默认为int
```
## 11.for区间迭代
```c++
for (auto vec : vectors) // read only
{
  cout << vec << endl;
}

for (atuo& vec : vectors) // writeable
{
  vet += 1;
}
```
## 12.mutex
1.两种RAII锁
1) lock_gruad<std::mutex>  
2) unique_gruad<std::mutex> // 中间还可以进行临时解锁   

# 其他需要注意问题
## 1.函数返回值
1）返回后构造出新的b来，a是被析构掉的
```c
string getString()
{
  string a = "123";
  return a;
}

string b = getString() // ok,b重新被构造，而a被析构

string& getString()
{
  string a = "123";
  return a;
}

string b = getString(); // 此时返回a的引用，但是a被析构，因此b会是空的
```
