# 队列
## 智能指针实现
```c++
template<typename T>
class queue
{
private:
  struct node
  {
    T data;
    std::unique_ptr<node> next;

    node(T data_):
    data(std::move(data_))
    {}
  };

  std::unique_ptr<node> head;  // 1
  node* tail;  // 2

public:
  queue()
  {}
  queue(const queue& other)=delete;
  queue& operator=(const queue& other)=delete;
  std::shared_ptr<T> try_pop()
  {
    if(!head)
    {
      return std::shared_ptr<T>();
    }
    std::shared_ptr<T> const res(
      std::make_shared<T>(std::move(head->data)));
    std::unique_ptr<node> const old_head=std::move(head); // 不能直接赋值head，而是先把它上面的指针转移走才可以
    head=std::move(old_head->next);  // 3
    return res;
  }

  void push(T new_value)
  {
    std::unique_ptr<node> p(new node(std::move(new_value)));
    node* const new_tail=p.get();
    if(tail)
    {
      tail->next=std::move(p);  // 4
    }
    else
    {
      head=std::move(p);  // 5
    }
    tail=new_tail;  // 6
  }
};
```

# 树
## 求树的高度
```c
int getDepth(TreeNode* root)
{
    if (root == NULL) return 0;
    return max(getDepth(root->left), getDepth(root->right)) + 1;
}

```
## 数的遍历
### 前序遍历
```c
void preFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
 
        std::cout << root->val << endl;
        preFindNode(root->left);
        preFindNode(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                cout << root->val << endl;
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                treeStack.pop();
                root = root->right;
            }
        }
    }
```
### 中序遍历
```c
    void midFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
        midFindNode(root->left);
        std::cout << root->val << endl;
        midFindNode(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                cout << root->val << endl;
                treeStack.pop();
                root = root->right;
            }
        }
    }

```
### 后序遍历
```c
    void tailFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
        tailFindNode(root->left);
        tailFindNode(root->right);
        std::cout << root->val << endl;
 
        // 非递归版 利用双栈实现
        stack<TreeNode*> treeStack1;
        stack<TreeNode*> treeStack2;
 
        treeStack1.push(root);
        while (!treeStack1.empty())
        {
            root = treeStack1.top();
            treeStack1.pop();
 
            treeStack2.push(root);
            if (root->left)
            {
                treeStack1.push(root->left);
            }
 
            if (root->right)
            {
                treeStack1.push(root->right);
            }
        }
 
        while (!treeStack2.empty())
        {
            TreeNode *tmp = treeStack2.top();
            treeStack2.pop();
            cout << tmp->val << endl;
        }
    }

```
## B树 B+树
### B树
1.使用B树作为索引树的原因  
虽然红黑树的查找效率更好，但是由于内存读取的局部性，红黑树节点的实际物理地址离得比较远，导致频繁从磁盘读取，影响速度  
而B树将节点按顺序放在一起，并且起到了索引的作用，减少了向磁盘的读取  
### B+树
1.优点  
1）非叶子节点只存储索引，不存储数据，进而能存储更多的索引  
2）数据都在叶子节点上，并且通过链表相连接，因此可以扫库，通过链表一次读取所有    


# 图
## 表示方法
### 邻接矩阵
```c
vector<vector<int>> grap;
```
### 邻接链表
```c
map<string, multiset<string>> grap;
map<string, list<string>> grap;
```
## 图算法
### DFS
1.非递归  
使用stack  
```c
while(栈S非空)
    x=栈S的顶元素(不出栈)；
    if(存在并找到未被访问的x的邻接点w) // 或者是邻接链表找不到节点
        访问w；visited[w]=1；
        w进栈;
    else
        x出栈；
                     
while (!stack.empty())
{
    string currNode = stack.top();
    if (!graph[currNode].empty())
    {
        stack.push(*graph[currNode].begin());
        graph[currNode].erase(graph[currNode].begin());
    }
    else
    {
        res.insert(res.begin(), currNode);
        stack.pop();
    }
}
```
2.递归  
```c
void dfs(map<string, multiset<string>>& grap, string &currNode)
{
    while (!grap[currNode].empty())
    {
        string nextNode = *grap[currNode].begin();
        grap[currNode].earse(grap[currNode].begin());
        dfs(grap, nextNode);
    }
    
    res.push_back(currNode);
}

void dfs(vector<vector<int>>& grap, vector<vector<int>>& visted, int from)
{
    for (int i = from; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (grap[i][j] && visted[i][j] == false)
            {
                visted[i][j] = true;
                dfs();
            }
        }
    }
}
```
### BFS
1.非递归  
使用队列，类似于树的层序遍历  

### A*

### Dijkstra
使用最小堆  


## 图计算
### 基础数据结构
G = (V, E, D) (vertex\ edge\ data)  


# 大数据
https://blog.csdn.net/v_july_v/article/details/7382693  
https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.02.html  
## 分而治之/hash映射 + hash统计 + 堆/快速/归并排序
1）分而治之/hash映射：数据太大，内存受限时，将大文件化成（取模映射）小文件 —— 类似于分布式中用一致哈希将数据分开  
2）hash_map统计：当大文件转化为小文件，使用hash_map(key, value)来进行统计   
3）堆/快排：统计完后，进行排序获取  
### 例1.海量日志数据，提取出某日访问百度次数最多的IP  
坑：  
1）ip地址有32位，总共有2^32=32亿（10^8）的IP数量，若创建一个数组去统计数量，2^32 * 4 = 16GB, 32位的内存空间也即4GB，内存中放不下，因此要分开  
算法：
1）分而治之/hash映射：hash(ip)%1000 映射成1000个小文件    
2）hash_map统计：当大文件转化为小文件，使用hash_map(ip, value)来进行统计 —— 分别统计出1000个小文件的最频繁IP地址  
3）堆/快排：统计完后，进行排序获取  
### 例2.寻找热门查询，300万个查询字符串中统计最热门的10个查询
坑：  
1）在于单位的换算  
```c
300万 * 255B = 300 * 10^4 * 2^8 B = 300 * 5*2 * 5*2 * 5*2 * 10 * 2^8 = 300 * 125 * 2^11 * 10 = 3000 * 2^18B = 3000 * 2^20 /4 B = 0.75GB 
100万 = 1000 * 2^10 = 2 ^ 20  = 1MB  
10亿 = 1GB  
```
算法：  
1）由上分析可以知道能够一次放入内存中，那么可以通过hashmap统计字符串数量  
2）根据寻找最大的第k个数的方法（堆排序最小堆priority_queue或者快排分半）  
### 例3.有一个1GB的文件，里面每一行都是一个词，词的大小不超过16字节，内存限制大小是1MB，返回频率最高的100个词
坑：  
1）仍然是内存的限制  
### 例4.海量数据分布在100台电脑中，想办法高效统计出这批数据的TOP10 
1.分别在每台电脑上使用堆求最大的10个数，然后将100台电脑的合并  
若同一种元素会在不同机器上同时出现，那么应该将所有的数据都读取一遍后重新hash  
### 例5.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复，按照query的频度排序
1.由于是重复的，所有将所有文件都读一遍重新hash分成10个文件，再进行统计和排序  
### 例5.给定a,b两个文件，各存放50亿个url，每个url占64字节，内存限制为4G，找出a和b共同的url
1）10亿（billion） = 1GB  
### 例6.100万个数中找出最大的100个数
快排：O(n)
堆：O(nlogK)  

## 多层划分
数据范围很大，不能直接利用hash表，需通过多次划分，逐步确定范围  
### 例1. 2.5亿个整数中找出不重复的整数个数，内存空间不足以容纳2.5亿个数
也是分啊，分成64个文件，然后再分别统计  
### 例2. 5亿个int找中位数  
方法1：  
根据每个整数的前5位可以划分出32个桶，且每个桶是排好序的，00000 < 00001 此时还知道每个桶中数字的数量，就可以判断中位数在哪个桶中  
方法2：
每次向内存加载1G的数字，比较第32位，0分在一个文件，1分在一个文件，此时1中都是负数，0中都是正数，比较两个文件的大小，看中位数在哪个文件中，丢弃其他的文件，并继续比较第31位  

## Bloom filter / Bitmap

# 常见
1.二分查找  
go: sort.Search() // 找到比目标值大的最小值  

