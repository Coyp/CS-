# Class相关

## 1.空类的大小

（sizeof） = 1，声明类型的实例时，必须在内存中占有一定的内存  

## 友元函数

特点

- 不是类成员
- 可以让外部函数访问内部 private 和 protected 的数据

## 2.运算符重载  

1）参数个数  

- 成员函数:函数的参数个数比原来参与运算的运算数少一个: 重载一元运算符没有参数、重载二元运算符只有一个参数；比如，a + b 的参数为1个，a = b 的参数为1个 -> 因为含有 this 指针
- 友元函数:参数个数与原运算数个数相同，因为没有this指针  

2）<<和>>只能用友元函数来重载

- 为了保证使用cin或者cout  

```c
friend istream & operator >>(istream & in, MyClass &c);
istream & operator >>(istream & in, MyClass &c){
  in >> c
  return in;
}
```

## 3.构造函数与析构函数  

1）  
构造函数是否能为虚函数：不能，构造函数的意义就是把这个类型给创建起来，地基都没有了谈什么  
析构函数是否能为虚函数：如果基类有派生类，则必须，否则会导致派生类的析构函数不能执行  
2）  
派生类构造函数调用重写函数：可以表现多态性 （说明构造函数执行前虚指针与虚表已经完成）  
派生类析构函数调用重写函数：可以表现多态性  
3）  
若构造函数与析构函数为私有函数  
构造函数和析构函数的调用是外部调用，因此设置为私有意味着不能完成实例化，但是可以通过static单例的方式创建在堆上  

## 4.类内成员变量初始化  

```c
class Test
{
public:
  Test() : y(1), r(y), d(3){} //对于常量型成员变量和引用型成员变量，必须通过参数化列表的方式进行初始化。
  ~Test(){}

  int y;      //普通变量成员
  int& r;     //引用成员变量,C11之前必须通过参数初始化列表进行初始化
  const int d;    //常量成员变量，C11之前必须通过参数初始化列表进行初始化
  static int c;   //静态成员变量，不属于类的实例，必须在类外部定义实现
  static const int x = 2.1;   //静态常量整型成员变量
  static const int xx;        //静态常量整型成员变量声明
};
  
const int Test::xx = 4; //静态常量整型成员变量定义
int Test::c = 2;
```

## 5.类实例化的过程

1）分配空间  
2）初始化  
<https://blog.csdn.net/gukesdo/article/details/7514080>

## 6.虚函数与虚表  

1）机制  

```c
class A {
  virtual void fa();
  virtual void ga();
};
class B {
  virtual void fb();
  virtual void gb();
};
class C : public A, public B{
  void fa();
  void fb();
  virtual void gc();
}
C继承了两个类，因此会有两个虚表
1) C::fa() A::ga() C::gc() // C中其他的虚拟成员被放到第一个继承类中
2) C::fb() B::gb()
```

2）一个类产生的所有实例共用同一个虚表，则虚指针都相同，虚表在全局变量区  
3）虚指针初始化与参数初始化一起执行，完成后再执行构造函数{ }里面的内容  
4）若子类没有虚函数，但是基类有，那么子类也会继承虚表和虚指针  
5）**纯虚函数**会使用地址0来占位，因此子类中必须重写，否则地址无效而无法继承 