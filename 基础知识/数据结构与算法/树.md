
# 树
## 求树的高度
```c
int getDepth(TreeNode* root)
{
    if (root == NULL) return 0;
    return max(getDepth(root->left), getDepth(root->right)) + 1;
}

```
## 数的遍历
### 前序遍历
```c
void preFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
 
        std::cout << root->val << endl;
        preFindNode(root->left);
        preFindNode(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                cout << root->val << endl;
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                treeStack.pop();
                root = root->right;
            }
        }
    }
```
### 中序遍历
```c
    void midFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
        midFindNode(root->left);
        std::cout << root->val << endl;
        midFindNode(root->right);
 
        // 非递归版
        if (root == nullptr) return;
        stack<TreeNode*> treeStack;
        while (root != nullptr || !treeStack.empty())
        {
            if (root != nullptr)
            {
                treeStack.push(root);
                root = root->left;
            }
            else
            {
                root = treeStack.top();
                cout << root->val << endl;
                treeStack.pop();
                root = root->right;
            }
        }
    }

```
### 后序遍历
```c
    void tailFindNode(TreeNode *root)
    {
        if (root == nullptr) return;
        tailFindNode(root->left);
        tailFindNode(root->right);
        std::cout << root->val << endl;
 
        // 非递归版 利用双栈实现
        stack<TreeNode*> treeStack1;
        stack<TreeNode*> treeStack2;
 
        treeStack1.push(root);
        while (!treeStack1.empty())
        {
            root = treeStack1.top();
            treeStack1.pop();
 
            treeStack2.push(root);
            if (root->left)
            {
                treeStack1.push(root->left);
            }
 
            if (root->right)
            {
                treeStack1.push(root->right);
            }
        }
 
        while (!treeStack2.empty())
        {
            TreeNode *tmp = treeStack2.top();
            treeStack2.pop();
            cout << tmp->val << endl;
        }
    }

```
## B树 B+树
### B树
1.使用B树作为索引树的原因  
虽然红黑树的查找效率更好，但是由于内存读取的局部性，红黑树节点的实际物理地址离得比较远，导致频繁从磁盘读取，影响速度  
而B树将节点按顺序放在一起，并且起到了索引的作用，减少了向磁盘的读取  
### B+树
1.优点  
1）非叶子节点只存储索引，不存储数据，进而能存储更多的索引  
2）数据都在叶子节点上，并且通过链表相连接，因此可以扫库，通过链表一次读取所有 


