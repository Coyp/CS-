https://pushmind.org/2017/07/31/design-patterns-for-humans/ C++版  
https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html  
重点：三种工厂、单例、桥接、观察者、访问者  


# 创建型
https://www.zhihu.com/question/20367734 图解工厂类  
```c++
class Car {};
class Audi : public Car {};
class Benz : public Car {};
```
## 简单工厂
// 新增类型必须再次修改工厂  
```c++
class SimpleCarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carType)
    {
        switch (carType)
        {
            case 0 :
                return std::make_shared(Audi());
            case 1 :
                return std::make_shared(Benz());
        }
    }
};
std::shared_ptr<SimpleCarFactory> simpleCarFactory = std::make_shared(SimpleCarFactory());
std::shared_ptr<Car> simpleCar = simpleCarFactory->createCar(1);

template <typename className>
class SimpleCarFactory
{
    std::shared_ptr<Car> createCar()
    {
        return std::make_shared(className());
    }
};
std::shared_ptr<Car> car = std::make_shared(SimpleCarFactory<Audi>());
```
## 工厂模式
// 工厂也被抽象出来，具体的实例化交给各个工厂各自实现  
// 先选择使用哪个工厂，再决定实现哪种产品  
```c++
class CarFactory 
{
public:
    virtual std::shared_ptr<Car> createCar(const int& carNum);
};

class AudioFactory : public CarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carNum) override
    {
        return std::make_shared(Audi());
    }
};

class BenzFactory : public CarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carNum) override
    {
        return std::make_shared(Benz());
    }
};

std::shared_ptr<CarFactory> carFactory = std::make_shared(AudioFactory());
std::shared_ptr<Car> car = carFactory->createCar(1);  
```
## 抽象工厂
// 工厂模式中增加新类型产品  
```c++
class TransportFactory
{
public:
    virtual std::shared_ptr<Car> createCar(const int& carNum);
    virtual std::shared_ptr<Bike> createBike(const int& bikeNum);
};
```
## 生成器
// 将构造函数中的参数列表方法化  
```c++
class Burger::BurgerBuilder {
public:
    BurgerBuilder(int size) { burger_ = new Burger(size); } // 注意此处并没有直接返回，仅仅进行了赋值
    BurgerBuilder& AddTomato() { burger_->tomato_ = true; return *this; }
    Burger* Build() { return burger_; } // 通过此处再返回
private:
    Burger* burger_;
};

Burger(int size, bool cheese = true, bool peperoni = true, bool tomato = false, bool lettuce = true);
Burger* burger = Burger::BurgerBuilder(14).AddPepperoni().AddLettuce().AddTomato().Build();
```
## 单例
// 双重校验
```java
public static Singleton getInstance() {
  if (instance_ == null) {
    synchronized(Singleton.class) {  //1
      if (instance_ == null)          //2
        instance_ = new Singleton();  //3
    }
  }
  return instance_;
}
```

# 结构型
https://www.cnblogs.com/kid-li/archive/2006/11/11/557359.html 结构型  
## 适配器
包装一个类型或者对象, 让本不兼容的类型变得兼容，实质是接口上的兼容  
```c
class WildDogAdapter : public ILion {
public:
    WildDogAdapter(WildDog& dog): dog_(dog) {}
    void Roar() override { // 重新包装了Roar
        dog_.Bark();
    }
private:
    WildDog& dog_;
};
```
## 桥接
将抽象部分和实现部分抽离，两部分能够分别变化，增加灵活度  
若有两个以上的变化点，可以隔离变化点，减少代码修改  
```c++
class ITheme {
public:
    virtual std::string GetColor() = 0;
};

class DarkTheme : public ITheme {
public:
    std::string GetColor() override { return "Dark Black"; }
};

class LightTheme : public ITheme {
public:
    std::string GetColor() override { return "Off white"; }
};

class IWebPage {
public:
    IWebPage(ITheme& theme) : theme_(theme) {}
    virtual std::string GetContent() = 0;
protected:
    ITheme& theme_;
};

class About : public IWebPage {
public:
    About(ITheme& theme) : IWebPage(theme) {}
    std::string GetContent() override {
        return "About page in " + theme_.GetColor();
    }
};

```
## 组合
多态的体现
```c++
class Employee {
public:
    Employee(const std::string& name, float salary): name_(name), salary_(salary) {}
    virtual std::string GetName() { return name_; }
    virtual float GetSalary() { return salary_; }
protected:
    float salary_;
    std::string name_;
};

class Developer : public Employee {
public:
    Developer(const std::string& name, float salary) : Employee(name, salary) {}
};

class Designer : public Employee {
public:
    Designer(const std::string& name, float salary) : Employee(name, salary) {}
};
```
## 装饰 ？
动态的给一个对象添加一些额外的功能，解决用继承的方式为对象扩展大量功能而造成的子对象数量膨胀的问题
```c++
ICoffee* someCoffee = new SimpleCoffee();
someCoffee = new MilkCoffee(*someCoffee); // 可以减少再创建MilkCoffe变量，在MilkCoffee中改造值  
```
## 外观
为复杂的子系统创建一个简单的接口  
多加一层的方式  
```c++
class ComputerFacade {
public:
    ComputerFacade(Computer& computer): computer_(computer) {}
    void TurnOn() {
        computer_.GetElectricShock();
        computer_.MakeSound();
        computer_.ShowLoadingScreen();
        computer_.Bam();
    }
}
computer.TurnOn();   
```
## 享元 ？
最基本的缓存思想，通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象  
## 代理
更像是一种伪装，核心是为了兼容用户习惯  

# 行为型
## 责任链
有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序  
本质其实是对象的单链表实现 + 对单链表的迭代  
```c++
Bank bank(100); //> Bank with balance 100
Paypal paypal(200); //> Paypal with balance 200
Bitcoin bitcoin(300); //> Bitcoin with balance 300

bank.SetNext(&paypal); // 类内部实现链接的调用
paypal.SetNext(&bitcoin);

bank.Pay(259);
```
## 命令


## 观察者
被观察者
``` c
resisterObserver()
removeObserver()
notifyObserver() // 更新时回调所有的对象
```
观察者
```c
// 
// 
```
