#操作系统基础

@(操作系统)

##1.内存管理

###背景
1.每个进程都有独立的内存空间，其范围由两个寄存器决定：基地址寄存器和界限地址寄存器
2.逻辑地址空间（虚拟地址空间）与物理地址空间：前者指由程序生成的，后者指物理地址
分成两类地址空间的原因：
虚拟存储器实现程序地址空间到物理地址的转换，这种地址转换处理加强了各个程序地址空间之间的保护
允许用户程序超过主要存储器的容量
3.分页：允许进程的物理地址空间可以是非连续的
  页表：每个程序都有自己的页表，用来将程序的虚拟地址空间映射到主存中去
  
###虚拟内存
1.定义：硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互
处理器+Sram+Dram+磁盘
2.Cache基本原理
![Alt text](./1529318601756.png)
3.使用位
记录是否被使用
4.脏位
若脏位被标记，说明内存中被更改，那么被置换时，需要将值写回内存，若没被标记，则可以直接丢弃

###内存页面置换算法
1.场景
当缺页时，操作系统接手从下级存储中寻找页
2.算法
1）FIFO先进先出：置换先进来的页面
2）LRU 最近最久未使用：置换最长时间没被引用的页面
3）LFU 最不常用：置换访问次数最少的页面


##2.进程管理
###进程调度算法

###进程之间通信
1.管道
1）特点
a. 用于具有血缘关系的进程之间的通信（父子进程或者兄弟进程）
2）例子
a. linux中 | 命令
b. 父进程和子进程之间的交互
![Alt text](./1529326438227.png)
2.命名管道（FIFO）
1）特点
a. 可以在无关的进程之间交换数据
b.以一种特殊设备文件形式存在于文件系统中（很类似于文件的操作，write/open等等）
2）例子
![Alt text](./1529330817240.png)
3.消息队列
消息的链接表，存放在内核中，一个消息队列由一个标识符（队列ID）来标识
1）特点
a.独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除
b.消息队列可以实现消息的随机查询，而不一定要以先进先出的次序读取
4.共享内存
两个或者多个进程共享一个给定的存储区域
1）信号量与共享内存通常结合在一起使用，信号量用来同步对共享内存的访问
5.信号量 
是一个计数器，信号量用于实现进程之间的互斥与同步，而不是用于存储进程间的通信数据
1）特点
a.信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
b.每次pv操作不仅限于对信号量的加1或减1，并且可以加减任意正整数

总结
1）管道：速度慢，容量有限，只有父子进程能通讯    
2）FIFO：任何进程间都能通讯，但速度慢    
3）消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
4）信号量：不能传递复杂消息，只能用来同步    
5）共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
###父子进程
1.定义
fork通过复制父进程来创建一个新的进程（子进程）
exec
2.特点
1）fork后会产生两个进程，子进程有其唯一的PID
2）fork后子进程的代码段、堆栈区、数据区和父进程一模一样（即创建时直接映射到父进程的物理地址）
3）当子进程进行运行时，才将堆栈区和数据区分开
4）一般会紧跟exec函数将子进程的代码段进行替换
3.孤儿进程
当父进程退出后，它的子进程还在运行，那么子进程会变成孤儿进程，孤儿进程会被init（进程号为1）所收养，并由init进程对它们完成状态收集工作
4.僵尸进程
一个进程fork创建子进程，如果子进程退出，而父进程没有调用wait或者waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中（因为父进程需要调用后知道子进程的终止状态）


##线程管理
###线程基本知识
1.线程的生命周期及状态转换
![Alt text](./1529421029627.png)
创建：new
就绪：start( ) //
运行：run( ) //其中包含了这个线程的内容（程序体）、若run中代码执行完毕则线程结束、若直接调用run方法只是调用一个方法而已，程序中仍然只有一个主线程
阻塞：wait/sleep/join等
https://blog.csdn.net/asdf_1024/article/details/78978437
2.java多线程编程
http://www.cnblogs.com/PerkinsZhu/p/7242247.html
1）java提供的锁
synchronized锁 JVM层锁 隐式的获取锁
reentranLock锁 JDK层锁 lock trylock unlock
3.C++多线程编程 （C++11）
https://github.com/forhappy/Cplusplus-Concurrency-In-Practice
4.锁（包括一些数据库中的锁）
1）
共享锁：读操作时，多个线程只要申请过共享锁既可读取
排它锁：只允许单个线程进行操作
2）
乐观锁：读不需要上锁，写的时候进行是否脏位的判断
悲观锁：读和写都要上锁
3）
可重入锁：若线程已经获取锁，可以在不释放资源的条件下重新获得锁
不可重入锁：若线程已经获取锁，重新获得锁之前必须释放资源
4）
公平锁：等待线程按照请求锁的先后顺序分别获取锁
非公平锁：等待线程获取锁的顺序和请求先后无关，可能随机获取或者按照某种规则获取
5）
自旋锁：请求锁等待时，不进行wait挂起，不释放cpu资源，持续执行while
非自旋锁：锁等待时，会释放CPU资源，多用sleep、wait、CPU中断等方式
5.future 模型
因为在多线程中使用全局变量比较危险，因此可以用future存储当前的结果给未来使用

###线程间通信
为了进程中的多个线程协同工作，因此需要手段进行线程之间的同步
Java中的线程通信方法
1.wait和notify/notifyall ——Object的方法
wait：挂起等待，放弃锁
notify：唤醒
2.await和signal/signalAll —— Condition的方法
Conditon.awati( )：挂起等待，放弃锁
Conditon.signal( )：唤醒
3.sleep/yield/join
sleep：让当前线程暂停一段时间，时间到后自动唤醒，期间不会释放任何持有的锁
yield：当前线程从运行状态转换为就绪状态，由线程调度重新选择就绪状态的线程分配资源
join：暂停当前线程（并不会释放锁），等待被调用线程指向结束后再继续执行（实际上使用了自旋锁）
4.信号量
Semaphore
同进程概念，提供了控制同时访问临界区资源的线程个数

###进程与线程区别


