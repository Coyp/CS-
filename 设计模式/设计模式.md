https://pushmind.org/2017/07/31/design-patterns-for-humans/ C++版  
https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html  
https://www.kancloud.cn/digest/suski-pattern/160457 大话设计模式读后  
重点：三种工厂、单例、桥接、观察者、访问者  


# 创建型

<https://www.zhihu.com/question/20367734> 图解工厂类  

```c++
class Car {};
class Audi : public Car {};
class Benz : public Car {};
```

## 工厂类

### 简单工厂

// 新增类型必须再次修改工厂  

```c++
class CarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carType)
    {
        switch (carType)
        {
            case 0 :
                return std::make_shared(Audi());
            case 1 :
                return std::make_shared(Benz());
        }
    }
};
std::shared_ptr<CarFactory> CarFactory = std::make_shared(CarFactory());
std::shared_ptr<Car> simpleCar = CarFactory->createCar(1);

template <typename className>
class CarFactory
{
    std::shared_ptr<Car> createCar()
    {
        return std::make_shared(className());
    }
};
std::shared_ptr<Car> car(CarFactory<Audi>());
```

### 工厂模式

// 工厂也被抽象出来，具体的实例化交给各个工厂各自实现  
// 先选择使用哪个工厂，再决定实现哪种产品  

```c++
class CarFactory
{
public:
    virtual std::shared_ptr<Car> createCar(const int& carNum);
};

class AudioFactory : public CarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carNum) override
    {
        return std::make_shared(Audi());
    }
};

class BenzFactory : public CarFactory
{
public:
    std::shared_ptr<Car> createCar(const int& carNum) override
    {
        return std::make_shared(Benz());
    }
};

std::shared_ptr<CarFactory> carFactory = std::make_shared(AudioFactory());
std::shared_ptr<Car> car = carFactory->createCar(1);  
```

### 抽象工厂

// 把不同工厂的共同的接口都抽象出来了

```c++
class TransportFactory
{
public:
    virtual std::shared_ptr<Car> createCar(const int& carNum);
    virtual std::shared_ptr<Bike> createBike(const int& bikeNum);
};
```

## 生成器

// 将构造函数中的参数列表方法化  

```c++
class Burger::BurgerBuilder {
public:
    BurgerBuilder(int size) { burger_ = new Burger(size); } // 注意此处并没有直接返回，仅仅进行了赋值
    BurgerBuilder& AddTomato() { burger_->tomato_ = true; return *this; } // 一个例子
    Burger* Build() { return burger_; } // 通过此处再返回
private:
    Burger* burger_;
};

Burger(int size, bool cheese = true, bool peperoni = true, bool tomato = false, bool lettuce = true);
Burger* burger = Burger::BurgerBuilder(14).AddPepperoni().AddLettuce().AddTomato().Build();
```

## 单例

1. 只能生成一个, 因此将构造函数设置为 private, 不能让外部调用产生实例

2. 以下双重校验也存在问题, //4 中先赋值了地址给 singleton_, 但可能构造函数还在构造中, 而 B 线程已经通过//1, 并返回了构造一半的函数

```c++
// 双重校验
class Singleton {
private:
    Singleton() {};

    std::mutex m_;
    static Singleton* singleton_;

public:
    Singleton* getInstance() {
        if (singleton_ == nullptr) { // 1 
            unique_lock<std::mutex> m(m_); // 2 
            if (singleton_ == nullptr) { // 3 
                singleton_ = new Singleton; // 4 
            }
        }
        return singleton_;
    }
};
Singleton* Singleton::singleton_ = nullptr; // 只能在类外初始化
```

3. c11 -> call_one 函数

```c++
static unique_ptr<widget> widget::instance;
static std::once_flag widget::create;
widget& widget::get_instance() {
  std::call_once(create, [=]{ instance = make_unique<widget>(); });
  return instance;
}

4. best
```c++
widget& widget::get_instance() {
  static widget instance  = new widget;
  return instance;
}
```

# 结构型

<https://www.cnblogs.com/kid-li/archive/2006/11/11/557359.html> 结构型  

## 适配器

包装一个类型或者对象, 让本不兼容的类型变得兼容，实质是接口上的兼容  

```c
class WildDogAdapter : public ILion {
public:
    WildDogAdapter(WildDog& dog): dog_(dog) {}
    void Roar() override { // 重新包装了Roar
        dog_.Bark();
    }
private:
    WildDog& dog_;
};
```

## 桥接

将抽象部分和实现部分抽离，两部分能够分别变化，增加灵活度  
若有两个以上的变化点，可以隔离变化点，减少代码修改  

```c++
class ITheme {
public:
    virtual std::string GetColor() = 0;
};

class DarkTheme : public ITheme {
public:
    std::string GetColor() override { return "Dark Black"; }
};

class LightTheme : public ITheme {
public:
    std::string GetColor() override { return "Off white"; }
};

class IWebPage {
public:
    IWebPage(ITheme& theme) : theme_(theme) {}
    virtual std::string GetContent() = 0;
protected:
    ITheme& theme_;
};

class About : public IWebPage {
public:
    About(ITheme& theme) : IWebPage(theme) {}
    std::string GetContent() override {
        return "About page in " + theme_.GetColor();
    }
};

```

## 组合

多态的体现

```c++
class Employee {
public:
    Employee(const std::string& name, float salary): name_(name), salary_(salary) {}
    virtual std::string GetName() { return name_; }
    virtual float GetSalary() { return salary_; }
protected:
    float salary_;
    std::string name_;
};

class Developer : public Employee {
public:
    Developer(const std::string& name, float salary) : Employee(name, salary) {}
};

class Designer : public Employee {
public:
    Designer(const std::string& name, float salary) : Employee(name, salary) {}
};
```

## 装饰 ？

动态的给一个对象添加一些额外的功能，解决用继承的方式为对象扩展大量功能而造成的子对象数量膨胀的问题

```c++
ICoffee* someCoffee = new SimpleCoffee();
someCoffee = new MilkCoffee(*someCoffee); // 可以减少再创建MilkCoffe变量，在MilkCoffee中改造值  
```

## 外观

为复杂的子系统创建一个简单的接口  
多加一层的方式  

```c++
class ComputerFacade {
public:
    ComputerFacade(Computer& computer): computer_(computer) {}
    void TurnOn() {
        computer_.GetElectricShock();
        computer_.MakeSound();
        computer_.ShowLoadingScreen();
        computer_.Bam();
    }
}
computer.TurnOn();

```

## 享元 ？

最基本的缓存思想，通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象  

## 代理

更像是一种伪装，核心是为了兼容用户习惯  

# 行为型

## 责任链

有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序  
本质其实是对象的单链表实现 + 对单链表的迭代  

```c++
Bank bank(100); //> Bank with balance 100
Paypal paypal(200); //> Paypal with balance 200
Bitcoin bitcoin(300); //> Bitcoin with balance 300

bank.SetNext(&paypal); // 类内部实现链接的调用
paypal.SetNext(&bitcoin);

bank.Pay(259);
```

## 命令

将所有的操作都封装到对象中，容易进行命令式执行或者回滚

## 迭代器

## 中介者

中介者模式增加了一个第三方对象(中介者)来控制两个对象间的交互。有助于彼此通信的解耦  

```c++
// 聊天室
ChatRoom mediator;
User john("John Doe", mediator);
User jane("Jane Doe", mediator);
john.Send("Hi, there!");
jane.Send("Hey!");
```

## 备忘录

缓存之前的变化，使用的时候再赋进去

## 观察者

当一个对象改变状态时，与他有依赖关系的对象都会收到通知  
本质是注入与回调  

``` c
resisterObserver()
removeObserver()
notifyObserver() // 更新时回调所有的对象
```

## 访问者

允许为对象们增加更多的操作，却不必修改它们  
额外的功能是vister定义，将其注册到原来的对象中  

```c
class Monkey : public Animal {
public:
    void Shout() { std::cout << "Ooh oo aa aa!" << std::endl; }
    void Accept(AnimalOperation& operation) override { operation.visitMonkey(*this); }
};

class Speak : public AnimalOperation {
public:
    void visitMonkey(Monkey& monkey) override { monkey.Shout(); }
    void visitLion(Lion& lion) override { lion.Roar(); }
    void visitDolphin(Dolphin& dolphin) override { dolphin.Speak(); }
};

Monkey monkey;
Lion lion;
Dolphin dolphin;

Speak speak; // 此处是新的方法
monkey.Accept(speak); // 注册给之前的类，让他拥有新的方法，并执行
lion.Accept(speak);
dolphin.Accept(speak);
```

## 策略

允许你根据实际情况切换算法或策略  
注入+多态，将接口注入，调用相应方法(算法或策略)时，再根据多态的特性来选择具体实现  

```c++
class Sorter {
public:
    static void Sort(std::vector<int>& vec, const std::shared_ptr<ISortStrategy>& sorter) // 继承ISortStrategy  
    { sorter->Sort(vec); }
};
```

## 状态

状态改变的同时, 也改变类的行为
